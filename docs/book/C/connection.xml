<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY mdash "&#8212;">
]>

<chapter id="chapter.connection">
  <title>Connections</title>

  <para>
   A <interfacename>Connection</interfacename> object in Telepathy
   represents an active (or activatable) protocol session. Connections are
   created by the appropriate
   <link linkend="sect.connection.connection-manager">Connection Manager</link>.
  </para>

  <para>
   A connection can be located on the D-Bus session bus via the well-known name
   <literal>org.freedesktop.Telepathy.Connection.cm.proto.account</literal>,
   where <literal>cm</literal> is the name of the Connection Manager that
   created the connection (e.g. gabble, salut) and <literal>proto</literal>
   is the name of a Telepathy <type>Protocol</type> (e.g. jabber, msn, irc).
   The connection object can then be retrieved from the path
   <literal>/org/freedesktop/Telepathy/Connection/cm/proto/account</literal>.
  </para>
     
  <para>
   Depending on what features are supported by the protocol, a given
   connection will implement more interfaces than just
   <interfacename>Connection</interfacename>. The interfaces supported by
   a given connection can be retreived using the
   <methodname>GetInterfaces</methodname> method once the connection is in
   the <literal>CONNECTED</literal> state. The supported list of interfaces
   doesn't change during the life on a connection, so it is expected that a
   client will retreive this once the connection is
   <literal>CONNECTED</literal>.
  </para>

  <para>
   Interfaces that a connection might support are:
  </para>
  <itemizedlist>
   <listitem>
    <para><interfacename>Requests</interfacename></para>
    <para>
     The <interfacename>Requests</interfacename> interface is used to
     obtain <link linkend="chapter.channel">channels</link>, which are how
     data is exchanged in Telepathy. Its use is documented in
     <xref linkend="sect.channel.requesting"/>.
    </para>
   </listitem>
   <listitem>
    <para><interfacename>Contacts</interfacename></para>
    <para>
     The <interfacename>Contacts</interfacename> interface is a sort of
     proxy to other interfaces on the connection. It is used to gather as
     much information about a contact as required in a single D-Bus
     roundtrip. It is documented in <xref linkend="sect.contactinfo.contacts"/>.
    </para>
   </listitem>
   <listitem>
    <para><interfacename>SimplePresence</interfacename></para>
    <para>
     The <interfacename>SimplePresence</interfacename> interface is used to
     set and obtain presence information on a given Connection. It is
     documented in <xref linkend="sect.connection.presence"/> and
     <xref linkend="sect.contactinfo.presence"/>.
    </para>
   </listitem>
   <listitem>
    <para>Avatars</para>
    <para>
     Describe me
    </para>
   </listitem>
   <listitem>
    <para>Capabilities</para>
    <para>
     Describe me
    </para>
   </listitem>
   <!--
   <listitem>
    <para>ContactCapabilities</para>
    <para>
     Draft
    </para>
   </listitem>
    -->
   <!--
   <listitem>
    <para>ContactInfo</para>
    <para>
     Draft
    </para>
   </listitem>
    -->
   <!--
   <listitem>
    <para>Location</para>
    <para>
     Draft
    </para>
   </listitem>
    -->
   <!--
   <listitem>
    <para>Presence</para>
    <para>
     Deprecated with extreme prejudice.
    </para>
   </listitem>
    -->
   <listitem>
    <para><interfacename>Renaming</interfacename></para>
    <para>
     <interfacename>Renaming</interfacename> is implemented for protocols
     that can allow handles to be renamed (e.g. IRC). It is documented in
     <xref linkend="sect.connection.renaming"/>.
    </para>
   </listitem>
  </itemizedlist>

  <sect1 id="sect.connection.connection-manager">
    <title>Connection Managers</title>
  
    <para>
     Support for the various communication protocols is provided by several
     <literal>Connection Managers</literal>. For instance, the
     <literal>telepathy-gabble</literal> Connection Manager provides support
     for the <acronym>XMPP</acronym> protocol, also known as
     <literal>Jabber</literal>.
    </para>
    
    <para>
     There is no central Telepathy D-Bus service in Telepathy. Instead there are
     several connection manager services, activated on demand. Each
     connection manager implements the Telepathy specification, allowing a
     Telepathy client to utilise any messaging protocol.
    </para>
  
    <para>
     All Telepathy Connection Managers have <literal>bus name</literal>s that
     begin with &quot;org.freedesktop.Telepathy.ConnectionManager&quot;.
     You can discover all available connection managers by calling the D-Bus
     <methodname>ListActivatableNames</methodname> method and then comparing
     the names with that prefix.
    </para>
    
    <para>
     A Connection Manager may implement more than one protocol (e.g.
     <application>telepathy-haze</application> is a connection manager using
     <application>libpurple</application> and thus provides many protocols).
     You may then discover what protocols are provided by each connection
     manager by calling the ConnectionManagers's
     <methodname>ListProtocols</methodname> method.
    </para>

    <para>
     In general, there is little need for a client to interact much with
     the <interfacename>ConnectionManager</interfacename> interface. Most of
     the work in obtaining and managing connections should be done via
     Mission Control.
    </para>

    <sect2 id="sect.connection.connection-manager.glib">
     <title>telepathy-glib</title>
     <para>
      telepathy-glib provides the
      <function>tp_list_connection_managers</function> function
      to list the available connection managers. This is demonstrated in
      <xref linkend="ex.connection.connection-manager.glib"/>.
     </para>
 
     <para>
      telepathy-glib's
      <classname>TpConnectionManager</classname>
      object automatically calls <methodname>ListProtocols</methodname> upon
      creation and emits the <literal>got-info</literal>
      signal when it has returned. You can examine the
      TpConnectionManager::protocols struct field in your signal handler.
     </para>

     <example id="ex.connection.connection-manager.glib"
              file="glib_list_protocols/example.c">
      <title>tp_list_connection_managers Example</title>
     </example>
    </sect2>
    
  </sect1>
  
  <sect1 id="sect.connection.obtaining">
    <title>Obtaining a Connection</title>

    <sect2 id="sect.connection.obtaining.account-manager">
     <title>From the Account Manager</title>

     <note>
      <para>
       The <interfacename>AccountManager</interfacename> and
       <interfacename>Account</interfacename> interfaces are implemented
       in <application>Mission Control 5</application>.
      </para>
      <para>
       <application>Mission Control 4</application> implements a completely
       different interface which is not documented here.
      </para>
     </note>

     <para>
      In general, Telepathy clients will want to share the same set of
      already-configured accounts rather than managing their own accounts
      and setting up their own connections. The
      <link linkend="chapter.accounts">Account Manager</link> manages
      connections for configured accounts which can be retrieved as a
      property from each <interfacename>Account</interfacename> object.
     </para>

     <para>
      Connections are created and managed by the Account Manager for valid,
      online accounts.
      The Account Manager is available via the well known D-Bus name
      <literal>org.freedesktop.Telepathy.AccountManager</literal> and object
      path <literal>/org/freedesktop/Telepathy/AccountManager</literal>.
     </para>

     <para>
      Valid, connectable (or connected) accounts are available via the
      <property>ValidAccounts</property> property of the Account Manager.
      This property contains a list of D-Bus object paths the Account
      Manager exports. An account's current presence can be read via the
      <property>CurrentPresence</property> property.
     </para>

     <para>
      To bring an account online, set
      <property>RequestedPresence</property> to an online state (e.g.
      <type>Connection_Presence_Type_Available</type> (the account must also
      be <property>Enabled</property>).
      Equally, to take an account offline, set the
      <property>RequestedPresence</property> property to
      <type>Connection_Presence_Type_Offline</type>.
     </para>

     <tip>
      <title>Automatically Onlining Accounts</title>
      <para>
       Mission Control will automatically bring online any
       <property>Enabled</property> account when a channel is requested for
       that account via the Channel Dispatcher. This is done by setting
       <property>RequestedPresence</property> to the value set in
       <property>AutomaticPresence</property>.
      </para>
      <para>
       See ...
      </para>
     </tip>

     <para>
      The <property>Connection</property> property gives the object path for
      the connection associated with the account. A value of
      <literal>/</literal> indicates that no connection has been created.
     </para>

     <para>
      The well-known bus name of the connection can be determined from the
      object path by removing the leading forward-slash and replacing
      the remaining slashes with periods (for example,
      <literal>/org/freedesktop/Telepathy/Connection/gabble/jabber/bob_40example_2ecom_2ftelepathy</literal>
      becomes
      <literal>org.freedesktop.Telepathy.Connection.gabble.jabber.bob_40example_2ecom_2ftelepathy</literal>).
      Note that doing this conversion is not normally required, as most
      Telepathy bindings are able to do it for you (e.g.
      <function>tp_connection_new</function>).
     </para>
    </sect2>

    <sect2 id="sect.connection.obtaining.connection-manager">
     <title>From a Connection Manager</title>
     <para>
      There might be times when you are using Telepathy without an
      Account Manager and need to manually set up your own connections using
      the Connection Manager. For example, a status reporting client that
      runs as its own user without a desktop session might only run itself,
      <application>dbus-daemon</application> and a Connection Manager.
     </para>

     <para>
      To setup your own connection to the remote server (e.g. your Jabber
      IM account) you need to call <methodname>RequestConnection</methodname>
      on the appropriate <link linkend="sect.connection.connection-manager">
      Connection Manager</link> (e.g. gabble), providing a map of connection
      details. Assuming the connection succeeds this method will return the
      <literal>bus name</literal> and <literal>object path</literal>
      of a newly created Telepathy <interfacename>Connection</interfacename>
      object.
     </para>

     <para>
      To determine what parameters are required or optional for a given
      Connection Manager its <methodname>GetParameters</methodname> method
      should be called with the relevant protocol.
      <xref linkend="example.connection.get_parameters"/> shows how this is
      done. Some common, &quot;well-known&quot; parameters names are shown
      in <xref linkend="table.connection.well_known_parameters"/>.
     </para>

     <example id="example.connection.get_parameters"
              file="python_get_parameters/example.py">
      <title>Getting Connection Parameters</title>
     </example>

     <table id="table.connection.well_known_parameters">
      <title>Well-Known Connection Parameters for RequestConnection</title>
      <tgroup cols="4">
       <colspec colname="property"/>
       <colspec colname="type"/>
       <colspec colname="description"/>
       <colspec colname="example"/>

       <thead>
        <row>
         <entry>Property</entry><entry>Type</entry>
         <entry>Description</entry><entry>Example</entry>
        </row>
       </thead>

       <tbody>
        <row>
	 <entry>account</entry><entry>String</entry>
	 <entry>
	  The identifier for the user's account on the server.
	 </entry>
	 <entry>bob@example.com</entry>
        </row>

	<row>
	 <entry>server</entry><entry>String</entry>
	 <entry>
	  A fully qualified domain name or numeric IPv4 or IPv6 address.
	 </entry>
	 <entry>xmpp.example.com</entry>
        </row>

	<row>
	 <entry>port</entry><entry>uint16</entry>
	 <entry>
	  A TCP/UDP network port.
	 </entry>
	 <entry>8080</entry>
	</row>

	<row>
	 <entry>require-encryption</entry><entry>Boolean</entry>
	 <entry>
	  Require encryption for this connection.
	 </entry>
	 <entry>False</entry>
        </row>

	<row>
	 <entry>register</entry><entry>Boolean</entry>
	 <entry>
	  This account should be created on the server if it does not
	  already exist.
	 </entry>
	 <entry>False</entry>
	</row>

	<row>
	 <entry>ident</entry><entry>String</entry>
	 <entry>
	  The local username to report to the server.
	 </entry>
	 <entry>bmcbadgers</entry>
	</row>

	<row>
	 <entry>fullname</entry><entry>String</entry>
	 <entry>
	  The user's full name.
	 </entry>
	 <entry>Bob McBadgers</entry>
	</row>

	<row>
	 <entry>stun-server</entry><entry>String</entry>
	 <entry>
	  A fully qualified domain name or numeric IPv4 or IPv6 address of a
	  STUN server to use for NAT traversal.
	 </entry>
	 <entry>stun.example.com</entry>
	</row>

	<row>
	 <entry>stun-port</entry><entry>uint16</entry>
	 <entry>
	  A UDP network port for the STUN server.
	 </entry>
	 <entry>1337</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

     <para>
      The new connection will not actually attempt to establish a network
      connection until its <methodname>Connect</methodname> method has been
      called. The connection will be ready to use after the
      <methodname>StatusChanged</methodname> signal returns a
      <type>Connection_Status</type> of <literal>Connected</literal>.
     </para>

     <para>
      <xref linkend="example.connection.establish-connection"/> shows how to
      manually establish a connection.
     </para>

     <!--
     <para>As of this writing, there is no hand-coded telepathy-glib function to request the connection and directly provide a <ulink url="&url_telepathy_glib_base;connection.html"><classname>TpConnection</classname></ulink> proxy. However, you may use the generated <ulink url="&url_telepathy_glib_base;connection-manager.html#tp_cli_connection_manager_call_request_connection"><function>tp_cli_connection_manager_call_request_connection()</function></ulink> function. In the callback, you can then use the provided <literal>bus name</literal> and <literal>object path</literal> to instantiate a TpConnection proxy object.</para>
 
     <note><para>See the <link linkend="sect.basics.language-bindings.telepathy-glib.generated">Basics</link> chapter for an explanation of hand-coded and generated API in telepathy-glib.</para></note>
 
     <para>See the <link linkend="chapter.channel">Channels</link> section about obtaining and using <interfacename>Channel</interfacename>s from the <interfacename>Connection</interfacename> with which you can list groups of contacts.</para>
     -->

     <example id="example.connection.establish-connection">
      <title>Establishing a Connection</title>
      <para></para><!-- bodge validity -->
      <!--
      url="&url_examples_base;connect">
      -->
     </example>
     
    </sect2>
  </sect1>

  <sect1 id="sect.connection.presence">
    <title>Presence</title>
    <para>
     If a protocol has the concept of presence, showing when users are
     online or available, then its <interfacename>Connection</interfacename>
     will provide the <interfacename>SimplePresence</interfacename> interface.
     This interface provides functions to set and get the user's current
     presence as well as the presence of other accounts (usually the accounts
     on the user's roster).
    </para>

    <warning>
     <title>Presence vs. SimplePresence</title>
     <para>
      The Telepathy API specification also specifies another presence interface
      <interfacename>Presence</interfacename>. This interface was deemed too
      complex and has summarily been deprecated. Telepathy clients should
      not use <interfacename>Presence</interfacename> and instead use
      <interfacename>SimplePresence</interfacename>.
     </para>
    </warning>

    <sect2 id="sect.connection.presence.user">
     <title>Setting the User's Presence</title>

     <sect3 id="sect.connection.presence.user.account-manager">
      <title>Via the Account Manager</title>
      <note>
       <para>
        The <interfacename>AccountManager</interfacename> and
        <interfacename>Account</interfacename> interfaces are not implemented
        in <application>Mission Control 5</application> exactly as they are
        specified in the Telepathy API specification.
       </para>

       <para>
        <application>Mission Control 4</application> implements a completely
        different interface which is not documented here.
       </para>
      </note>

      <para>
       If this Connection was obtained from the
       <link linkend="chapter.accounts">Account Manager</link>, then the
       user's presence can be set on the appropriate
       <link linkend="sect.accounts.accounts">Account</link> object using
       the <property>RequestedPresence</property> property of the
       <interfacename>Account</interfacename> interface. This property takes
       a <type>SimplePresence</type> as its value.
      </para>
     </sect3>

     <sect3 id="sect.connection.presence.connection">
      <title>Via the Connection</title>
      <para>
       The user sets their own presence via the
       <methodname>SetPresence</methodname> method. Parameters are a status
       identifier (e.g. available, away, hidden) and an optional status message
       (e.g. &quot;At the Movies&quot;). Valid status identifiers for this
       connection can be retrieved using the <property>Statuses</property>
       property. This is shown in
       <xref linkend="ex.connection.presence.set-presence"/>.
      </para>

      <example id="ex.connection.presence.set-presence"
               file="python_simple_presence/example.py">
       <title>Requesting the Statuses and Setting Our Presence</title>
      </example>

     </sect3>
    </sect2>

    <sect2 id="sect.connection.presence.contacts">
     <title>Retrieving Contacts' Presence</title>

     <para>
      This is documented in
      <xref linkend="sect.contactinfo.presence"/>.
     </para>

    </sect2>

  </sect1>

  <sect1 id="sect.connection.renaming">
   <title>Handle Renaming</title>

   <para>
    In some protocols, contacts can change their contact handle identifier
    (the one passed to <methodname>RequestHandles</methodname> and returned
    by <methodname>InspectHandles</methodname>). For example on the IRC
    protocol, a user may change his/her &quot;nick&quot; (their Telepathy
    handle) from <literal>sheeba</literal> to <literal>sheeba|afk</literal>.
    This renaming is facilitated by the
    <interfacename>Renaming</interfacename> interface.
   </para>

   <sect2 id="sect.connection.renaming.self">
    <title>Changing Your Own Handle Name</title>

    <para>
     The method <methodname>RequestRename</methodname> can be called to
     change the string identifier for your own handle. This is used, for
     example, to change your IRC nick.
    </para>

    <para>
     The <methodname>Renamed</methodname> signal will be emitted for your
     own handle id (the handle returned by
     <methodname>GetSelfHandle</methodname>), as with any other handle
     rename, so you don't need to special-case your own handle renaming in
     the user interface view.
    </para>

    <para>
     A given protocol may enforce certain rules with regards to possible
     handles (valid characters), or whether your handle can be changed at
     this time (e.g. IRC channels have a mode bit that disables rename while
     you're a member). Thus <methodname>RequestRename</methodname> can
     return several possible, non-fatal errors that should be reported to
     the user.
     <!-- FIXME: how does a client discover what's possible, to inform
          the user? -->
    </para>
   </sect2>

   <sect2 id="sect.connection.renaming.signal">
    <title>Receiving Renames</title>

    <note>
     <para>
      Rename announcements depend on the protocol specification. Just holding
      a handle or being in a channel which has that contact as a member may
      not be enough to get the rename announcement.
     </para>

     <para>
      For example, in IRC you must be a member of a chatroom with the user
      to receive the rename notification.
     </para>
    </note>

    <para>
     Handle IDs are considered to be immutable, so when the identifier
     changes, a new handle ID is issued.
     When a contact changes its identifier,
     the <methodname>Renamed</methodname> signal will be emitted providing
     the original handle ID and a new ID for the contact.
    </para>

    <para>
     If the contact is a member of channels that implement
     <interfacename>Group</interfacename> (e.g. contact lists or chatrooms),
     these will emit <methodname>MembersChanged</methodname> after
     <methodname>Renamed</methodname> has been emitted. The reason
     (<type>Channel_Group_Change_Reason</type>) will be given as Renamed.
    </para>

   </sect2>

  </sect1>

</chapter>
