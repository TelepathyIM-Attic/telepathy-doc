<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY mdash "&#8212;">
  <!ENTITY appversion "0.7">
  <!ENTITY manrevision "0.2">
  <!ENTITY date "12 August 2008">
  <!ENTITY app_no_markup "Telepathy">
  <!ENTITY app "<application>&app_no_markup;</application>">
  <!ENTITY url_examples_base "./examples/">
  <!ENTITY url_spec "http://telepathy.freedesktop.org/spec.html">
  <!ENTITY url_spec_base "&url_spec;#org.freedesktop.Telepathy.">
  <!ENTITY url_telepathy_glib_base "http://telepathy.freedesktop.org/doc/telepathy-glib/telepathy-glib-">
  <!ENTITY url_dbus_spec_base "http://dbus.freedesktop.org/doc/dbus-specification.html#">
  <!ENTITY url_dbus_glib_base "http://dbus.freedesktop.org/doc/dbus-glib/">
  <!ENTITY url_dbus_python_base "http://dbus.freedesktop.org/doc/dbus-python/api/">
]>

<chapter id="chapter-channel">
  <title>Channel</title>
  <para>
   Each <interfacename>Connection</interfacename> provides
   <ulink url="&url_spec_base;Channel"><interfacename>Channel</interfacename></ulink>s,
   which allow the local application to exchange data with the remote server,
   for instance to retrieve a list of contacts in a chat room, or to send a
   message to a contact.
  </para>
  <para>
   Channels always provide at least two D-Bus interfaces interfaces:
   <interfacename>org.freedesktop.telepathy.Channel</interfacename>,
   and another interface according to the type of channel it is (which can
   be retrieved using the <property>ChannelType</property> property).
   For instance, a text channel provides the
   <interfacename>org.freedesktop.telepathy.ChannelType.Text</interfacename>
   interface.
  </para>
  
  <para>
   The channel types currently available in Telepathy are:
  </para>
  <variablelist>

     <varlistentry>
       <term>
         <indexterm><primary>ContactList</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.ContactList"><interfacename>ContactList</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel provides a list of people on the server, such as the
	  contacts to whose presence information you are subscribed or the
	  contacts to whom you publish your presence information.
	 </para>
	 <para>
	  See <xref linkend="sect-channel-contactlist"/>.
	 </para>
       </listitem>
     </varlistentry>
     
     <varlistentry>
       <term>
         <indexterm><primary>RoomList</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.RoomList"><interfacename>RoomList</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  A channel type for listing named channels (e.g. chatrooms)
	  available on the server.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>Text</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.Text"><interfacename>Text</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel sends and receives plain text messages, such as instant
	  messages.
	 </para>
	 <para>
	  See <xref linkend="sect-channel-text"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>StreamedMedia</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.StreamedMedia"><interfacename>StreamedMedia</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel sends and receives streamed audio or video,
	  such as a video call.
	 </para>
       </listitem>
     </varlistentry>
     
     <!--varlistentry>
       <term>
         <indexterm><primary>Tubes</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.Tubes"><interfacename>Tubes</interfacename></ulink>
       </term>
       <listitem>
         <para>
	 </para>
       </listitem>
     </varlistentry-->
     
     <varlistentry>
       <term>
         <indexterm><primary>FileTransfer</primary></indexterm>
         <ulink
	 url="&url_spec_base;Channel.Type.FileTransfer"><interfacename>FileTransfer</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  A channel type for transferring files.
	 </para>
       </listitem>
     </varlistentry>

  </variablelist>
  
  <sect1 id="sec-channel-requesting">
    <title>Requesting Channels</title>

    <para>
     Channels are requested from a <classname>Connection</classname> object
     using the <ulink url="&url_spec_base;Connection.Interface.Requests"><interfacename>Requests</interfacename></ulink>
     interface.
    </para>

    <para>
     This interface provides two methods:
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname>.
     Both methods take the same parameter, a dictionary containing the
     desired properties for the channel.
    </para>

    <para>
     <methodname>CreateChannel</methodname> will attempt to create a new
     channel with the requested properties. Depending on the protocol, some
     types of channels are exclusive, and only one such channel can exist at
     a time (e.g. a XMPP chatroom). If a second channel is requested, the
     error <errorname>NotAvailable</errorname> is returned.
    </para>

    <para>
     Conversely, <methodname>EnsureChannel</methodname> will attempt to reuse an
     existing channel with the same properties wherever possible, else it
     will create a new channel. It's possible that another client is also
     utilising this channel. <!-- FIXME: write more on this -->
    </para>

    <tip>
     <title>When to Create and when to Ensure</title>
     <para>
      Choosing when to always create a new channel, or when to use an
      existing channel can usually be deduced based on the function of the
      channel. If it would make sense to reuse an existing channel then
      use <methodname>EnsureChannel</methodname>, otherwise use
      <methodname>CreateChannel</methodname>.
     </para>
     <para>
      <methodname>EnsureChannel</methodname> is usually used for
      <interfacename>Text</interfacename>,
      <interfacename>StreamedMedia</interfacename> and
      <interfacename>ContactList</interfacename> channels.
     </para>
     <para>
      <methodname>CreateChannel</methodname> is usually used for
      <interfacename>FileTransfer</interfacename>,
      <interfacename>Tubes</interfacename>,
      <interfacename>RoomList</interfacename> and
      <interfacename>ContactSearch</interfacename> channels.
     </para>
    </tip>

    <para>
     The properties argument for <methodname>RequestChannel</methodname> and
     <methodname>EnsureChannel</methodname> is a map of property names on
     the desired channel, and their values.
     In general every channel requires at least three channel
     properties: the type of channel we wish to create
     (<property>ChannelType</property>), the handle/id of the contact/room/list
     we wish to create a channel for (<property>TargetHandle</property> or
     <property>TargetID</property>) and the type of that handle
     (<property>TargetHandleType</property>). Specific channel types may
     require additional properties in order to be created, this is noted in
     the specification.
    </para>

    <para>
     For example, to create a <interfacename>ContactList</interfacename>
     channel (this is the type of channel that is used to get a list of
     subscribed contacts from a service), we might provide a map like so:
    </para>

    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
	<entry>Handle_Type_List</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
	<entry>"subscribe"</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <para>
     Telepathy-glib provides the
     <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-create-channel"><function>tp_cli_connection_interface_requests_call_create_channel()</function></ulink>
     and <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-ensure-channel"><function>tp_cli_connection_interface_requests_call_ensure_channel()</function></ulink>
     functions for this purpose.
    </para>

   <warning>
    <title>RequestChannel</title>
    <para>
     Some Connection Managers might not yet implement the
     <interfacename>Requests</interfacename> interface on their
     <classname>Connection</classname>s. In these cases you can
     use the <methodname>RequestChannel</methodname> method on the
     <interfacename>Connection</interfacename> interface, but you do so at
     your own risk.
    </para>
    <para>
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> fix several flaws that were
     present in <methodname>RequestChannel</methodname>:
    </para>
    <itemizedlist>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't provide a way to insist
      on a new channel or prefer an existing channel;
     </para></listitem>
     <listitem><para>
      If <methodname>RequestChannel</methodname> returns an existing
      channel, the caller is not told whether the channel can be safely
      handled or if something else is handling it already;
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> can request a channel type,
      a handle type and a handle, but nothing more elaborate
      (e.g. you can't request a <interfacename>RoomList</interfacename>
      with a particular server); and
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't return the channel's
      immutable properties (which is a useful optimization).
     </para></listitem>
    </itemizedlist>

    <para>
     If you must call <methodname>RequestChannel</methodname>, XXX WRITE ME
    </para>
   </warning>

  </sect1>

  <sect1 id="sect-channel-contactlist">
    <title>Contact Lists</title>
    <indexterm><primary>ContactList</primary></indexterm>
  
    <para>
     The <interfacename>ContactList</interfacename>
     channel type provides a list of people on the server, such as the contacts
     in a chat room, or the contacts to whose presence information you are
     subscribed.
    </para>
  
    <para>
     Like individual remote contacts themselves, lists of remote contacts
     is referred to by numeric
     <link linkend="sec-basics-handles">handle</link> of type
     <type>Handle_Type_List</type> (for
     <link linkend="sect.channel.contactlist.server-defined">server defined
     lists</link>) or
     <type>Handle_Type_Group</type> (for a user defined list of contacts).
     The handle can be retrieved using the
     <methodname>RequestHandles</methodname> method on the Connection.
    </para>

    <para>
     Two request a contact list, 3 properties must be provided to
     <methodname>EnsureChannel</methodname>
     (see <xref linkend="sec-channel-requesting"/>): the channel type
     (org.freedesktop.Telepathy.Channel.Type.ContactList), the target handle
     type (either <type>Handle_Type_List</type> or
     <type>Handle_Type_Group</type>) and
     either a target handle retrieved by
     <methodname>RequestHandles</methodname> or the ID.
    </para>
  
    <example id="example.channel.contactlist.examplemaps">
     <title>Example Maps For Requesting a Contact List</title>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
 	<entry>"subscribe"</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_Group</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </example>

    <para>
     Gaining access to the contacts listed in a contact list is actually
     achieved using the Channel's <interfacename>Group</interfacename>
     interface, which all <interfacename>ContactList</interfacename> objects
     implement. See <xref linkend="sect.channel.groups"/>.
    </para>

    <sect2 id="sect.channel.contactlist.server-defined">
     <title>Server Defined Lists</title>
     <para>
      A particular messaging protocol will likely provide a number of
      contact lists to a client, e.g. the list of subscribed contacts. These
      are the server defined lists (Handle_Type_List).
     </para>

     <para>
      Telepathy provides for several server-defined lists, but not all of
      them may be implemented by a given protocol, or even a given version
      of a protocol server. If you attempt to open a channel for a list that
      doesn't exists, an error will be returned. This error is not fatal, it
      simply means that list doesn't exist.
     </para>

     <para>
      Telepathy knows about the following server-defined lists:
     </para>

     <variablelist>
      <varlistentry><term>subscribe</term>
       <listitem><para>
        the group of contacts for whom you receive presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>publish</term>
       <listitem><para>
        the group of contacts who may receive your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>hide</term>
       <listitem><para>
        a group of contacts who are on the publish list but are temporarily
	disallowed from receiving your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>allow</term>
       <listitem><para>
        a group of contacts who may send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>deny</term>
       <listitem><para>
        a group of contacts who may not send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>stored</term>
       <listitem><para>
        on protocols where the user's contacts are stored, this contact list
	contains all stored contacts regardless of subscription status
       </para></listitem>
      </varlistentry>

     </variablelist>
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.groups">
     <title>Contact Groups</title>
     <!--
     TODO:
     (used in lots of different channels)
     - This is partitioned into:
       - Current members
       - Local pending members, awaiting approval (by doing Add or Remove) by the 
         local user.
       - Remote pending members, awaiting approval remotely by the other user)
     - Unusually, one-to-one calls use the <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface to indicate call 
       progression (explain in call section?).
    -->
    <para>
     The <interfacename>Group</interfacename> interface is implemented by
     several channel types including contact list channels and multi-user
     chat channels.
    </para>

    <para>
     For any given group there may be current members, local pending members
     and remote pending members. These are respectively accessed via the
     <property>Members</property>, <property>LocalPendingMembers</property>
     and <property>RemotePendingMembers</property> D-Bus properties.
    </para>

    <para>
     <property>Members</property> is a list of handles of members who are
     currently part of this channel. This might be contacts in a contact list
     or participants in a multi-user chat. The
     <methodname>AddMembers</methodname> and
     <methodname>RemoveMembers</methodname> (or
     <methodname>RemoveMembersWithReason</methodname>) may be used to
     manipulate this list. Note that <methodname>AddMembers</methodname> may
     move a member onto the <property>RemotePendingMembers</property> list.
    </para>

    <para>
     <property>LocalPendingMembers</property> is a list of members who are
     pending the user's approval (e.g. to subscribe to your presence, join
     a chatroom, etc.). Members are approved using the
     <methodname>AddMembers</methodname> method, and declined using the
     <methodname>RemoveMembers</methodname> method.
     As well as handles, the <property>LocalPendingMembers</property>
     provides a handle to the actor that made the request and a reason for
     the change (which may be empty).
    </para>

    <para>
     <property>RemotePendingMembers</property> is a list of contacts who
     are pending another approval to be added to the channel (e.g. a remote
     user allowing subscription to their presence).
    </para>

    <note><para>
     If a person has multiple instant message accounts, for instance via
     different protocols, Telepathy has no way of knowing that these are
     actually the same person, and no way for your application to tell
     Telepathy this. Therefore, client applications should track this
     information if necessary.
    </para></note>
  
  </sect1>
  
  <sect1 id="sect-channel-text">
    <title>Text Channel</title>
    <indexterm><primary>Text</primary></indexterm>
  
    <para>
     The <ulink url="&url_spec_base;Channel.Type.Text"><interfacename>Text</interfacename></ulink>
     channel sends and receives plain text messages, such as instant
     messages. Each <interfacename>Text</interfacename> channel represents
     communication with a contact or group of contacts. A group of contacts
     can be considered as a &quot;chat room&quot;. This contact or contacts
     list must be specified when creating the channel with
     <methodname>CreateChannel()</methodname>.
    </para>
  
    <para>
     The remote contact or contact list can be referred to by numeric
     <link linkend="sec-basics-handles"><literal>Handles</literal></link>
     (<property>TargetHandle</property>) or identifier
     (<property>TargetID</property>) when obtaining the
     <interfacename>Text</interfacename> channel, for instance via the
     <methodname>CreateChannel()</methodname> or
     <methodname>EnsureChannel()</methodname> D-Bus method, as described in
     the <link linkend="sec-channel-requesting">Requesting Channels</link>
     section.
    </para>
  
    <para>
     TODO: Notes: Password interfaces
    </para>
  
    <sect2 id="sec-channel-text-sending">
      <title>Sending Messages</title>
      <para>
       Messages may be sent to the contact (or contact list) with the
       <ulink url="&url_spec_base;Channel.Type.Text.Send"><methodname>Send()</methodname></ulink>
       method. Sending messages can be requested using the Send method,
       which will return successfully. Other parts of your application may
       handle the <literal>Sent</literal> signal, for instance to log that
       side of the conversation.
      </para>
    
      <note>
       <para>
        Some Connection Managers also provide the
        <ulink url="&url_spec_base;Channel.Interface.Messages"><interface>Messages</interface></ulink>
        interface on the <interfacename>Text</interfacename> channel object.
        This optional interface allows sending and receiving of formatted
        messages and delivery reports. For instance, you might use the
        <interfacename>Message</interfacename> interface's
        <ulink url="&url_spec_base;Channel.Interface.Messages.SendMessage"><methodname>SendMessage()</methodname></ulink>
        method instead of the main <interfacename>Text</interfacename>
        interface's <methodname>Send()</methodname> method.
       </para>
      </note>
  
      <sect3>
        <title>Example</title>
        <para>This example sends a text message to a jabber contact via a text channel.</para>
        <para><ulink url="&url_examples_base;send_message">Source Code</ulink></para>
      </sect3>
    </sect2>
  
    <sect2 id="sec-channel-text-receiving">
      <title>Receiving Messages</title>
      <para>TODO</para>
    
      <para>TODO: Notes: - Text channels may have ChatState (typing notification).</para> 
  
      <sect3>
        <title>Example</title>
        <para>This example receives text messages from a jabber contact via a text channel.</para>
        <!-- TODO: <para><ulink url="&url_examples_base;receive_message">Source Code</ulink></para> -->
      </sect3>
    </sect2>
  
  </sect1>

</chapter>
