<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY mdash "&#8212;">
  <!ENTITY appversion "0.7">
  <!ENTITY manrevision "0.2">
  <!ENTITY date "12 August 2008">
  <!ENTITY app_no_markup "Telepathy">
  <!ENTITY app "<application>&app_no_markup;</application>">
  <!ENTITY url_examples_base "./examples/">
  <!ENTITY url_spec "http://telepathy.freedesktop.org/spec.html">
  <!ENTITY url_spec_base "&url_spec;#org.freedesktop.Telepathy.">
  <!ENTITY url_telepathy_glib_base "http://telepathy.freedesktop.org/doc/telepathy-glib/telepathy-glib-">
  <!ENTITY url_dbus_spec_base "http://dbus.freedesktop.org/doc/dbus-specification.html#">
  <!ENTITY url_dbus_glib_base "http://dbus.freedesktop.org/doc/dbus-glib/">
  <!ENTITY url_dbus_python_base "http://dbus.freedesktop.org/doc/dbus-python/api/">
]>

<chapter id="chapter-channel">
  <title>Channels</title>
  <para>
   Each <interfacename>Connection</interfacename> provides
   <ulink url="&url_spec_base;Channel"><interfacename>Channel</interfacename></ulink>s,
   which allow the local application to exchange data with the remote server,
   for instance to retrieve a list of contacts in a chat room, or to send a
   message to a contact.
  </para>
  <para>
   Channels always provide at least two D-Bus interfaces interfaces:
   <interfacename>org.freedesktop.telepathy.Channel</interfacename>,
   and another interface according to the type of channel it is (which can
   be retrieved using the <property>ChannelType</property> property).
   For instance, a text channel provides the
   <interfacename>org.freedesktop.telepathy.ChannelType.Text</interfacename>
   interface.
  </para>
  
  <para>
   The channel types currently available in Telepathy are:
  </para>
  <variablelist>

     <varlistentry>
       <term>
         <indexterm><primary>ContactList</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.ContactList"><interfacename>ContactList</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel provides a list of people on the server, such as the
	  contacts to whose presence information you are subscribed or the
	  contacts to whom you publish your presence information.
	 </para>
	 <para>
	  See <xref linkend="sect-channel-contactlist"/>.
	 </para>
       </listitem>
     </varlistentry>
     
     <varlistentry>
       <term>
         <indexterm><primary>RoomList</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.RoomList"><interfacename>RoomList</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  A channel type for listing named channels (e.g. chatrooms)
	  available on the server.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>Text</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.Text"><interfacename>Text</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel sends and receives plain text messages, such as instant
	  messages.
	 </para>
	 <para>
	  See <xref linkend="sect-channel-text"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>StreamedMedia</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.StreamedMedia"><interfacename>StreamedMedia</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  This channel sends and receives streamed audio or video,
	  such as a video call.
	 </para>
       </listitem>
     </varlistentry>
     
     <!--varlistentry>
       <term>
         <indexterm><primary>Tubes</primary></indexterm>
         <ulink url="&url_spec_base;Channel.Type.Tubes"><interfacename>Tubes</interfacename></ulink>
       </term>
       <listitem>
         <para>
	 </para>
       </listitem>
     </varlistentry-->
     
     <varlistentry>
       <term>
         <indexterm><primary>FileTransfer</primary></indexterm>
         <ulink
	 url="&url_spec_base;Channel.Type.FileTransfer"><interfacename>FileTransfer</interfacename></ulink>
       </term>
       <listitem>
         <para>
	  A channel type for transferring files.
	 </para>
       </listitem>
     </varlistentry>

  </variablelist>
  
  <sect1 id="sec-channel-requesting">
    <title>Requesting Channels</title>

    <para>
     Channels are requested from a <classname>Connection</classname> object
     using the <ulink url="&url_spec_base;Connection.Interface.Requests"><interfacename>Requests</interfacename></ulink>
     interface.
    </para>

    <para>
     This interface provides two methods:
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname>.
     Both methods take the same parameter, a dictionary containing the
     desired properties for the channel.
    </para>

    <para>
     <methodname>CreateChannel</methodname> will attempt to create a new
     channel with the requested properties. Depending on the protocol, some
     types of channels are exclusive, and only one such channel can exist at
     a time (e.g. a XMPP chatroom). If a second channel is requested, the
     error <errorname>NotAvailable</errorname> is returned.
    </para>

    <para>
     Conversely, <methodname>EnsureChannel</methodname> will attempt to reuse an
     existing channel with the same properties wherever possible, else it
     will create a new channel. It's possible that another client is also
     utilising this channel. <!-- FIXME: write more on this -->
    </para>

    <tip>
     <title>When to Create and when to Ensure</title>
     <para>
      Choosing when to always create a new channel, or when to use an
      existing channel can usually be deduced based on the function of the
      channel. If it would make sense to reuse an existing channel then
      use <methodname>EnsureChannel</methodname>, otherwise use
      <methodname>CreateChannel</methodname>.
     </para>
     <para>
      <methodname>EnsureChannel</methodname> is usually used for
      <interfacename>Text</interfacename>,
      <interfacename>StreamedMedia</interfacename> and
      <interfacename>ContactList</interfacename> channels.
     </para>
     <para>
      <methodname>CreateChannel</methodname> is usually used for
      <interfacename>FileTransfer</interfacename>,
      <interfacename>Tubes</interfacename>,
      <interfacename>RoomList</interfacename> and
      <interfacename>ContactSearch</interfacename> channels.
     </para>
    </tip>

    <para>
     The properties argument for <methodname>RequestChannel</methodname> and
     <methodname>EnsureChannel</methodname> is a map of property names on
     the desired channel, and their values.
     In general every channel requires at least three channel
     properties: the type of channel we wish to create
     (<property>ChannelType</property>), the handle/id of the contact/room/list
     we wish to create a channel for (<property>TargetHandle</property> or
     <property>TargetID</property>) and the type of that handle
     (<property>TargetHandleType</property>). Specific channel types may
     require additional properties in order to be created, this is noted in
     the specification.
    </para>

    <para>
     For example, to create a <interfacename>ContactList</interfacename>
     channel (this is the type of channel that is used to get a list of
     subscribed contacts from a service), we might provide a map like so:
    </para>

    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
	<entry>Handle_Type_List</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
	<entry>"subscribe"</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <para>
     Telepathy-glib provides the
     <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-create-channel"><function>tp_cli_connection_interface_requests_call_create_channel()</function></ulink>
     and <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-ensure-channel"><function>tp_cli_connection_interface_requests_call_ensure_channel()</function></ulink>
     functions for this purpose.
    </para>

   <warning>
    <title>RequestChannel</title>
    <para>
     Some Connection Managers might not yet implement the
     <interfacename>Requests</interfacename> interface on their
     <classname>Connection</classname>s. In these cases you can
     use the <methodname>RequestChannel</methodname> method on the
     <interfacename>Connection</interfacename> interface, but you do so at
     your own risk.
    </para>
    <para>
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> fix several flaws that were
     present in <methodname>RequestChannel</methodname>:
    </para>
    <itemizedlist>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't provide a way to insist
      on a new channel or prefer an existing channel;
     </para></listitem>
     <listitem><para>
      If <methodname>RequestChannel</methodname> returns an existing
      channel, the caller is not told whether the channel can be safely
      handled or if something else is handling it already;
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> can request a channel type,
      a handle type and a handle, but nothing more elaborate
      (e.g. you can't request a <interfacename>RoomList</interfacename>
      with a particular server); and
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't return the channel's
      immutable properties (which is a useful optimization).
     </para></listitem>
    </itemizedlist>

    <para>
     If you must call <methodname>RequestChannel</methodname>, XXX WRITE ME
    </para>
   </warning>

  </sect1>

  <sect1 id="sect-channel-contactlist">
    <title>Contact Lists</title>
    <indexterm><primary>ContactList</primary></indexterm>
  
    <para>
     The <interfacename>ContactList</interfacename>
     channel type provides a list of people on the server, such as the contacts
     in a chat room, or the contacts to whose presence information you are
     subscribed.
    </para>
  
    <para>
     Like individual remote contacts themselves, lists of remote contacts
     is referred to by numeric
     <link linkend="sec-basics-handles">handle</link> of type
     <type>Handle_Type_List</type> (for
     <link linkend="sect.channel.contactlist.server-defined">server defined
     lists</link>) or
     <type>Handle_Type_Group</type> (for a
     <link linkend="sect.channel.contactlist.user-defined">user defined list of contacts</link>).
     The handle can be retrieved using the
     <methodname>RequestHandles</methodname> method on the Connection.
    </para>

    <para>
     To request a contact list, three properties must be provided to
     <methodname>EnsureChannel</methodname>
     (see <xref linkend="sec-channel-requesting"/>): the channel type
     (org.freedesktop.Telepathy.Channel.Type.ContactList), the target handle
     type (either <type>Handle_Type_List</type> or
     <type>Handle_Type_Group</type>) and
     either a target handle retrieved by
     <methodname>RequestHandles</methodname> or the ID.
     <xref linkend="ex.channel.contactlist.ensurechannel"/> shows a code
     example.
    </para>
  
    <example id="example.channel.contactlist.examplemaps">
     <title>Example Maps For Requesting a Contact List</title>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
 	<entry>"subscribe"</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_Group</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </example>
    
    <example id="ex.channel.contactlist.ensurechannel"
             file="python_simple_presence/example.py">
     <title>Setting Up a Channel for a ContactList</title>
    </example>

    <para>
     Gaining access to the contacts listed in a contact list is actually
     achieved using the Channel's <interfacename>Group</interfacename>
     interface, which all <interfacename>ContactList</interfacename> objects
     implement. See <xref linkend="sect.channel.groups"/>.
    </para>

    <sect2 id="sect.channel.contactlist.server-defined">
     <title>Server Defined Lists</title>
     <para>
      A particular messaging protocol will likely provide a number of
      contact lists to a client, e.g. the list of subscribed contacts. These
      are the server defined lists (Handle_Type_List).
     </para>

     <para>
      Telepathy provides for several server-defined lists, but not all of
      them may be implemented by a given protocol, or even a given version
      of a protocol server. If you attempt to open a channel for a list that
      doesn't exists, an error will be returned. This error is not fatal, it
      simply means that list doesn't exist.
     </para>

     <para>
      Telepathy knows about the following server-defined lists:
     </para>

     <variablelist>
      <varlistentry><term>subscribe</term>
       <listitem><para>
        the group of contacts for whom you receive presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>publish</term>
       <listitem><para>
        the group of contacts who may receive your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>hide</term>
       <listitem><para>
        a group of contacts who are on the publish list but are temporarily
	disallowed from receiving your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>allow</term>
       <listitem><para>
        a group of contacts who may send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>deny</term>
       <listitem><para>
        a group of contacts who may not send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>stored</term>
       <listitem><para>
        on protocols where the user's contacts are stored, this contact list
	contains all stored contacts regardless of subscription status
       </para></listitem>
      </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="sect.channel.contactlist.user-defined">
     <title>User Defined Groups</title>

     <para>
      User-defined groups are the groups that a user places their contacts
      into. Not all protocols may support the concept of user-defined
      groups. In some protocols (e.g. XMPP) a contact may possibly be in
      more than one group.
     </para>

     <para>
      Channels will be set up for user-defined groups as they are discovered
      by the connection. Thus the currently configured groups can be
      discovered at any time by checking the <property>Channels</property>
      property or connecting to the <methodname>NewChannels</methodname>
      signal on the <interfacename>Requests</interfacename> interface.
     </para>

     <para>
      This returns a list of <type>Channel_Details</type>, which gives the
      channel object and a map of properties for the channel. This map
      always contains the properties
      <property>Channel.ChannelType</property>,
      <property>Channel.TargetHandleType</property>,
      <property>Channel.TargetHandle</property>,
      <property>Channel.TargetID</property>, and
      <property>Channel.Requested</property>.
      Filtering on <property>Channel.ChannelType</property> equals
      <interfacename>Channel.Type.ContactList</interfacename> and
      <property>Channel.TargetHandleType</property> equals
      <type>Handle_Type_Group</type> will yield the user-defined contact
      groups.
     </para>
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.groups">
     <title>Contact Groups</title>
     <!--
     TODO:
     (used in lots of different channels)
     - This is partitioned into:
       - Current members
       - Local pending members, awaiting approval (by doing Add or Remove) by the 
         local user.
       - Remote pending members, awaiting approval remotely by the other user)
     - Unusually, one-to-one calls use the <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface to indicate call 
       progression (explain in call section?).
    -->
    <para>
     The <interfacename>Group</interfacename> interface is implemented by
     several channel types including contact list channels and multi-user
     chat channels.
    </para>

    <para>
     For any given group there may be current members, local pending members
     and remote pending members. These are respectively accessed via the
     <property>Members</property>, <property>LocalPendingMembers</property>
     and <property>RemotePendingMembers</property> D-Bus properties.
    </para>

    <para>
     <property>Members</property> is a list of handles of members who are
     currently part of this channel. This might be contacts in a contact list
     or participants in a multi-user chat. The
     <methodname>AddMembers</methodname> and
     <methodname>RemoveMembers</methodname> (or
     <methodname>RemoveMembersWithReason</methodname>) may be used to
     manipulate this list. Note that <methodname>AddMembers</methodname> may
     move a member onto the <property>RemotePendingMembers</property> list.
    </para>

    <para>
     <property>LocalPendingMembers</property> is a list of members who are
     pending the user's approval (e.g. to subscribe to your presence, join
     a chatroom, etc.). Members are approved using the
     <methodname>AddMembers</methodname> method, and declined using the
     <methodname>RemoveMembers</methodname> method.
     As well as handles, the <property>LocalPendingMembers</property>
     provides a handle to the actor that made the request and a reason for
     the change (which may be empty).
    </para>

    <para>
     <property>RemotePendingMembers</property> is a list of contacts who
     are pending another approval to be added to the channel (e.g. a remote
     user allowing subscription to their presence).
    </para>

    <note><para>
     If a person has multiple instant message accounts, for instance via
     different protocols, Telepathy has no way of knowing that these are
     actually the same person, and no way for your application to tell
     Telepathy this. Therefore, client applications should track this
     information if necessary.
    </para></note>

    <para>
     Information about a list of contacts can be looked up using the
     connection's <interfacename>Contacts</interfacename> interface. This
     is documented in <xref linkend="sect.connection.contacts"/>.
    </para>

    <para>
     <xref linkend="ex.channel.groups.getting-members"/> shows how to
     retrieve a list of handles for current members of a group (in this case
     a contact list).
    </para>

    <example id="ex.channel.groups.getting-members"
             file="python_simple_presence/example.py">
     <title>Retrieving the Members of a Group</title>
    </example>
  
  </sect1>
  
  <sect1 id="sect-channel-text">
    <title>Text Channels</title>
    <indexterm><primary>Text</primary></indexterm>
  
    <para>
     A <interfacename>Text</interfacename> channel sends and receives text
     messages, such as instant
     messages. Each <interfacename>Text</interfacename> channel represents
     communication with a contact or group of contacts
     (e.g. a &quot;chat room&quot;).
    </para>

    <para>
     Channels for text chat are usually <emphasis>ensured</emphasis>
     (see <xref linkend="sec-channel-requesting"/>) with the channel type
     <type>Channel_Type_Text</type>. For one-to-one chats, the target handle
     is a contact (<type>Handle_Type_Contact</type>). For named chatrooms
     (e.g. Jabber multi-user-chats, IRC chatrooms) the target handle is a
     room (<type>Handle_Type_Room</type>); these channels should support the
     <interfacename>Group</interfacename> interface.
    </para>

    <para>
     Some protocols (e.g. MSN) support transient, unnamed chatrooms that
     are just defined by their members. These chatrooms are represented by
     an anonymous channel (<type>Handle_Type_None</type>, handle id 0) and
     implement the <interfacename>Group</interfacename> interface. On some
     protocols, i.e. ones where all chats are simply transient chatrooms,
     setting up a channel for a one-to-one chat with a contact may result
     in this type of channel; with the target contact simply a member.
    </para>

    <para>
     A summary of the various text channels is given in
     <xref linkend="table.channel.text.channels-summary"/>.
    </para>

    <table id="table.channel.text.channels-summary">
     <title>Summary of Text Channels</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Channel Function</entry>
	<entry>Example Usage</entry>
	<entry>Required Handle Type</entry>
	<entry>Required Interfaces</entry>
	<entry>Notes</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry>One-to-One Chat</entry>
	<entry>XMPP 1-1 chat, IRC private messages</entry>
	<entry><type>Handle_Type_Contact</type></entry>
	<entry></entry>
	<entry>
	 Requests for this sort of channel may be upgraded to a transient
	 chatroom.
        </entry>	
       </row>

       <row>
        <entry>Named Chatroom</entry>
	<entry>XMPP MUC, IRC chatroom</entry>
	<entry><type>Handle_Type_Room</type></entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry></entry>
       </row>

       <row>
        <entry>Transient Chatroom</entry>
	<entry>MSN conversation</entry>
	<entry>Handle_Type_None</entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry>Appears as an anonymous channel.</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

    <para>
     When the user wishes to part from a conversation, the channel's
     <methodname>Close</methodname> method should be called. The channel
     will be closed when the channel emits the
     <methodname>Closed</methodname> signal. Be aware that if there are
     still pending messages on the channel when it closes, a new, identical
     channel will be created by the connection (heralded by the
     <methodname>NewChannel</methodname> signal). This is to prevent message
     loss due to a possible race.
     <!-- FIXME: how does this fit into ChannelDispatcher -->
     For one-to-one chats, this is identical to when a remote user sends you
     a message.
    </para>

    <note>
     <title>Close vs. Destroy</title>
     <para>
      To prevent any possible message loss, closing a channel with pending
      messages using the <methodname>Close</methodname> method will cause a
      new, identical channel to respawn that is the continuation of the
      original channel.
     </para>
     <para>
      Occasionally this behaviour is undesireable/problematic. For example,
      when a particular text channel keeps crashing/causing errors in the
      message renderer. Closing the channel will cause it to respawn with
      the offending messages. In this case the
      <methodname>Destroy</methodname> method of the
      <interfacename>Destroyable</interfacename> interface can be used to
      ensure a channel is not respawned, dropping any pending messages on
      the channel.
     </para>
    </note>

    <sect2 id="sec.channel.text.password">
     <title>Private Channels</title>

     <para>
      Some channels (usually chatrooms) require a password to be able to
      join them. Telepathy exposes this via the
      <interfacename>Password</interfacename> interface.
     </para>

     <para>
      Once a channel has been set up, and the interfaces retrieved, clients
      should check for the presence of the
      <interfacename>Password</interfacename> interface and if it exists
      call the <methodname>GetPasswordFlags</methodname> method. Telepathy
      currently has one flag: <type>Channel_Password_Flags_Provide</type>.
      If this flag is set, a password must be provided before the channel
      can be completely set up. Call the
      <methodname>ProvidePassword</methodname> method. If this returns true,
      then channel setup can continue.
     </para>

    </sect2>
  
    <sect2 id="sec.channel.text.rich">
     <title>Rich Text Interface</title>
     <para>
     </para>
    </sect2>

    <sect2 id="sect.channel.text.simple">
     <title>Simple Messaging Interface</title>
      <para>
       Messages may be sent to the contact (or contact list) with the
       <ulink url="&url_spec_base;Channel.Type.Text.Send"><methodname>Send()</methodname></ulink>
       method. Sending messages can be requested using the Send method,
       which will return successfully. Other parts of your application may
       handle the <literal>Sent</literal> signal, for instance to log that
       side of the conversation.
      </para>
    
      <note>
       <para>
        Some Connection Managers also provide the
        <ulink url="&url_spec_base;Channel.Interface.Messages"><interface>Messages</interface></ulink>
        interface on the <interfacename>Text</interfacename> channel object.
        This optional interface allows sending and receiving of formatted
        messages and delivery reports. For instance, you might use the
        <interfacename>Message</interfacename> interface's
        <ulink url="&url_spec_base;Channel.Interface.Messages.SendMessage"><methodname>SendMessage()</methodname></ulink>
        method instead of the main <interfacename>Text</interfacename>
        interface's <methodname>Send()</methodname> method.
       </para>
      </note>
  
    </sect2>
  
  </sect1>

</chapter>
