<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY mdash "&#8212;">
]>

<chapter id="chapter.channel">
  <title>Channels</title>
  <para>
   Each <interfacename>Connection</interfacename> provides
   <interfacename>Channel</interfacename>s,
   which allow the local application to exchange data with the remote server,
   for instance to retrieve a list of contacts in a chat room, or to send a
   message to a contact.
  </para>
  <para>
   Channels always provide at least two D-Bus interfaces interfaces:
   <interfacename>org.freedesktop.telepathy.Channel</interfacename>,
   and another interface according to the type of channel it is (which can
   be retrieved using the <property>ChannelType</property> property).
   For instance, a text channel provides the
   <interfacename>org.freedesktop.telepathy.ChannelType.Text</interfacename>
   interface.
  </para>
  
  <para>
   The channel types currently available in Telepathy are:
  </para>
  <variablelist>

     <varlistentry>
       <term>
         <indexterm><primary>ContactList</primary></indexterm>
         <interfacename>ContactList</interfacename>
       </term>
       <listitem>
         <para>
	  This channel provides a list of people on the server, such as the
	  contacts to whose presence information you are subscribed or the
	  contacts to whom you publish your presence information.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.contactlist"/>.
	 </para>
       </listitem>
     </varlistentry>
     
     <varlistentry>
       <term>
         <indexterm><primary>RoomList</primary></indexterm>
         <interfacename>RoomList</interfacename>
       </term>
       <listitem>
         <para>
	  A channel type for listing named channels (e.g. chatrooms)
	  available on the server.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.roomlist"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>Text</primary></indexterm>
         <interfacename>Text</interfacename>
       </term>
       <listitem>
         <para>
	  This channel sends and receives text messages, such as instant
	  messages.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.text"/> and then
	  <xref linkend="chapter.messaging"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>StreamedMedia</primary></indexterm>
         <interfacename>StreamedMedia</interfacename>
       </term>
       <listitem>
         <para>
	  This channel sends and receives streamed audio or video,
	  such as a video call.
	 </para>
       </listitem>
     </varlistentry>
     
     <!--varlistentry>
       <term>
         <indexterm><primary>Tubes</primary></indexterm>
         <interfacename>Tubes</interfacename>
       </term>
       <listitem>
         <para>
	 </para>
       </listitem>
     </varlistentry-->
     
     <varlistentry>
       <term>
         <indexterm><primary>FileTransfer</primary></indexterm>
         <interfacename>FileTransfer</interfacename>
       </term>
       <listitem>
         <para>
	  A channel type for transferring files.
	 </para>
	 <para>
	  File transfers are covered in-depth in
	  <xref linkend="chapter.filetransfer"/>.
	 </para>
       </listitem>
     </varlistentry>

  </variablelist>
  
  <sect1 id="sect.channel.requesting">
    <title>Requesting Channels</title>

    <para>
     Channels are requested from a <classname>Connection</classname> object
     using the <interfacename>Requests</interfacename> interface.
    </para>

    <para>
     This interface provides two methods:
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname>.
     Both methods take the same parameter, a dictionary containing the
     desired properties for the channel.
    </para>

    <para>
     <methodname>CreateChannel</methodname> will attempt to create a new
     channel with the requested properties. Depending on the protocol, some
     types of channels are exclusive, and only one such channel can exist at
     a time (e.g. a XMPP chatroom). If a second channel is requested, the
     error <errorname>NotAvailable</errorname> is returned.
    </para>

    <para>
     Conversely, <methodname>EnsureChannel</methodname> will attempt to reuse an
     existing channel with the same properties wherever possible, else it
     will create a new channel. It's possible that another client is also
     utilising this channel. <!-- FIXME: write more on this -->
    </para>

    <tip>
     <title>When to Create and when to Ensure</title>
     <para>
      Choosing when to always create a new channel, or when to use an
      existing channel can usually be deduced based on the function of the
      channel. If it would make sense to reuse an existing channel then
      use <methodname>EnsureChannel</methodname>, otherwise use
      <methodname>CreateChannel</methodname>.
     </para>
     <para>
      <methodname>EnsureChannel</methodname> is usually used for
      <interfacename>Text</interfacename>,
      <interfacename>StreamedMedia</interfacename> and
      <interfacename>ContactList</interfacename> channels.
     </para>
     <para>
      <methodname>CreateChannel</methodname> is usually used for
      <interfacename>FileTransfer</interfacename>,
      <interfacename>Tubes</interfacename>,
      <interfacename>RoomList</interfacename> and
      <interfacename>ContactSearch</interfacename> channels.
     </para>
    </tip>

    <para>
     The properties argument for <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> is a map of property names on
     the desired channel, and their values.
     In general every channel requires at least three channel
     properties: the type of channel we wish to create
     (<property>ChannelType</property>), the handle/id of the contact/room/list
     we wish to create a channel for (<property>TargetHandle</property> or
     <property>TargetID</property>) and the type of that handle
     (<property>TargetHandleType</property>). Specific channel types may
     require additional properties in order to be created, this is noted in
     the specification.
    </para>

    <para>
     For example, to create a <interfacename>ContactList</interfacename>
     channel (this is the type of channel that is used to get a list of
     subscribed contacts from a service), we might provide a map like so:
    </para>

    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
	<entry>Handle_Type_List</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
	<entry>"subscribe"</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    
   <note>
    <title>Anonymous Channels</title>
    <para>
     Anonymous channels are channels that do not connect to a remote
     (single) contact, room, list or group. For example,
     <interfacename>RoomList</interfacename> channels, or anonymous MUC
     chats (e.g. in MSN).
    </para>
    <para>
     They are requested by giving a <property>TargetHandleType</property>
     of <type>Handle_Type_None</type> (you should <emphasis>not</emphasis>
     specify a <property>TargetHandle</property> for an anonymous channel).
    </para>
   </note>

   <sect2 id="sect.channel.requesting.requestchannel">
    <title>The RequestChannel Method</title>

    <warning>
     <title>Deprecated</title>
     <para>
      The <methodname>RequestChannel</methodname> method has been deprecated
      and should only be used if compatibility is required with older
      Connection Managers that do not implement the
      <interfacename>Requests</interfacename> interface. 
     </para>
    </warning>

    <para>
     Some Connection Managers might not yet implement the
     <interfacename>Requests</interfacename> interface on their
     <classname>Connection</classname>s. In these cases you can
     use the <methodname>RequestChannel</methodname> method on the
     <interfacename>Connection</interfacename> interface, but you do so at
     your own risk.
    </para>
    <para>
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> fix several flaws that were
     present in <methodname>RequestChannel</methodname>:
    </para>
    <itemizedlist>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't provide a way to insist
      on a new channel or prefer an existing channel;
     </para></listitem>
     <listitem><para>
      If <methodname>RequestChannel</methodname> returns an existing
      channel, the caller is not told whether the channel can be safely
      handled or if something else is handling it already;
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> can request a channel type,
      a handle type and a handle, but nothing more elaborate
      (e.g. you can't request a <interfacename>RoomList</interfacename>
      with a particular server); and
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't return the channel's
      immutable properties (which is a useful optimization).
     </para></listitem>
    </itemizedlist>

    <para>
     If you must call <methodname>RequestChannel</methodname>, you call it
     with the same three arguments required for all channels (channel type,
     handle type and handle). The <parameter>Suppress_Handler</parameter>
     argument should <emphasis>always</emphasis> be True.
     <xref linkend="ex.channel.requestchannel"/> shows how to do this.
    </para>

    <example id="ex.channel.requestchannel"
             file="python_irc_roomlist/example.py">
     <title>Requesting a channel using RequestChannel</title>
    </example>

    <para>
     When requesting an anonymous channel with
     <methodname>RequestChannel</methodname>, a channel with handle type
     <type>Handle_Type_None</type> (as is the case in
     <xref linkend="ex.channel.requestchannel"/>), pass the handle id
     <literal>0</literal>.
    </para>
   </sect2>

   <sect2 id="sect.channel.requesting.python">
    <title>telepathy-python</title>

    <para>
      telepathy-python provides the
      <classname>telepathy.client.Channel</classname> class as a D-Bus proxy
      object. To construct this proxy you need to pass the connection's
      D-Bus service name and the path to the channel object.
    </para>

    <para>
     <classname>telepathy.client.Channel</classname> can be inherited like
     any other Python class, so that you can pass around all of the methods
     and state relating to that channel as one object. This is shown in
     <xref linkend="ex.channel.requesting.python.class"/>.
    </para>

    <example id="ex.channel.requesting.python.class"
             file="python_iface_messaging/example.py">
     <title>Inheriting telepathy.client.Channel</title>
    </example>
   </sect2>
   
   <sect2 id="sect.channel.requesting.glib">
    <title>telepathy-glib</title>
    
    <para>
     <application>telepathy-glib</application> maps
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> to the functions
     <function>tp_cli_connection_interface_requests_call_create_channel</function>
     and <function>tp_cli_connection_interface_requests_call_ensure_channel</function>
     respectively. <xref linkend="ex.channel.requesting.glib.ensure"/>
     shows how this is done.
    </para>

    <example id="ex.channel.requesting.glib.ensure"
             file="glib_get_roster/example.c">
     <title>Ensuring a Channel With telepathy-glib</title>
    </example>

    <para>
     The <classname>TpChannel</classname> is used to work with channels in
     <application>telepathy-glib</application>. It also provides API to help
     use the <link linkend="sect.channel.groups">Groups interface</link>,
     that is present on many channels.
    </para>

    <para>
     A <classname>TpChannel</classname> can either be created using
     <function>tp_channel_new</function> or
     <function>tp_channel_new_from_properties</function>. The latter is more
     useful when you've created a channel using the
     <interfacename>Requests</interfacename> interface,
     as you can just pass in the returned property map, as shown in
     <xref linkend="ex.channel.requesting.glib.tpchannel"/>.
    </para>

    <example id="ex.channel.requesting.glib.tpchannel"
             file="glib_get_roster/example.c">
     <title>Using tp_channel_new_from_properties</title>
    </example>

   </sect2>

  </sect1>

  <sect1 id="sect.channel.newchannels">
   <title>Incoming Channels</title>

   <para>
    Besides channels that you request yourself, channels can be created by a
    remote user (e.g. text, or file transfer channels) or by the server you
    are connected to (e.g. contact group channels).
   </para>

   <para>
    New channels are heralded by the <methodname>NewChannels</methodname>
    signal, which is part of the <interfacename>Requests</interfacename>
    interface.
   </para>

   <para>
    When channels are created, the <methodname>NewChannels</methodname>
    callback will pass you a list of newly created channels by their object
    paths along with a map of immutable properties for the channel.
    All channels are announced, including channels that you created. You
    can check the <property>Requested</property> property to discover if
    this channel is one you requested yourself (i.e. via
    <methodname>CreateChannel</methodname>).
   </para>

   <tip>
    <para>
     It is possible to call <methodname>CreateChannel</methodname> in a
     fire-and-forget way (if you don't care about error conditions), or only
     handle the error condition in the method callback, and do
     all of the channel setup in the <methodname>NewChannels</methodname>
     callback, using a common codepath for channels you requested, and
     channels you did not (e.g. setting up a new text channel).
    </para>
    <para>
     If required, use the <property>Requested</property> property to determine
     if you created the channel yourself.
    </para>
   </tip>

   <para>
    Use the <property>ChannelType</property> property to decide how to
    handle a channel.
   </para>

   <sect2 id="sect.channel.newchannels.newchannel">
    <title>The NewChannel Signal</title>
    <warning>
     <title>Deprecated</title>
     <para>
      The <methodname>NewChannel</methodname> signal has been deprecated
      and should only be used if compatibility is required with older
      Connection Managers that do not implement the
      <interfacename>Requests</interfacename> interface.
     </para>
    </warning>

    <para>
     <methodname>NewChannel</methodname>, like the method call
     <methodname>RequestChannel</methodname>, is part of the old channel
     requesting API and should not be used in new programs unless absolutely
     required because a Connection Manager does not support
     <interfacename>Requests</interfacename> (although this is a bug in the
     Connection Manager).
    </para>

    <para>
     <methodname>NewChannels</methodname> has several advantages over
     the older <methodname>NewChannel</methodname>:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Related channels (or channels created as a side-effect of another
       creation) can be bundled together.
      </para>
      <para>
       For example, creating a multi-user Tube in XMPP requires joining the
       corresponding multi-user chatroom, so both channels can be announced
       in the same signal.
      </para>
     </listitem>
     <listitem>
      <para>
       The callback includes a map with all of the channel's immutable
       properties, a useful optimisation.
      </para>
     </listitem>
    </itemizedlist>

    <note>
     <para>
      <methodname>NewChannels</methodname> is always emitted first, followed
      by a <methodname>NewChannel</methodname> signal for each of the
      channels.
     </para>
    </note>

    <para>
     The parameters to the <methodname>NewChannel</methodname> signal, and
     their equivalents in <methodname>NewChannels</methodname> is presented
     in <xref linkend="table.channel.newchannels.newchannel.mapping"/>.
    </para>

    <table id="table.channel.newchannels.newchannel.mapping">
     <title>NewChannel Parameters to NewChannels Properties</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Parameter</entry>
	<entry>Type</entry>
	<entry><methodname>NewChannels</methodname> equivalent</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><parameter>Object_Path</parameter></entry>
	<entry>D-Bus Object Path (<literal>o</literal>)</entry>
	<entry><parameter>Channel</parameter> parameter</entry>
       </row>
       <row>
        <entry><parameter>Channel_Type</parameter></entry>
	<entry>String</entry>
	<entry>
	 <property>org.freedesktop.Telepathy.Channel.ChannelType</property>
	 property
	</entry>
       </row>
       <row>
        <entry><parameter>Handle_Type</parameter></entry>
	<entry>uint32</entry>
	<entry>
	 <property>org.freedesktop.Telepathy.Channel.TargetHandleType</property>
	 property
	</entry>
       </row>
       <row>
        <entry><parameter>Handle</parameter></entry>
	<entry>uint32</entry>
	<entry>
	 <property>org.freedesktop.Telepathy.Channel.TargetHandle</property>
	 property
	</entry>
       </row>
       <row>
        <entry><parameter>Suppress_Handler</parameter></entry>
	<entry>Boolean</entry>
	<entry>-</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   </sect2>
  </sect1>

  <sect1 id="sect.channel.contactlist">
    <title>Contact Lists</title>
    <indexterm><primary>ContactList</primary></indexterm>
  
    <para>
     The <interfacename>ContactList</interfacename>
     channel type provides a list of people on the server, such as the contacts
     in a chat room, or the contacts to whose presence information you are
     subscribed.
    </para>
  
    <para>
     Like individual remote contacts themselves, lists of remote contacts
     is referred to by numeric
     <link linkend="sect.basics.handles">handle</link> of type
     <type>Handle_Type_List</type> (for
     <link linkend="sect.channel.contactlist.server-defined">server defined
     lists</link>) or
     <type>Handle_Type_Group</type> (for a
     <link linkend="sect.channel.contactlist.user-defined">user defined list of contacts</link>).
     The handle can be retrieved using the
     <methodname>RequestHandles</methodname> method on the Connection.
    </para>

    <para>
     To request a contact list, three properties must be provided to
     <methodname>EnsureChannel</methodname>
     (see <xref linkend="sect.channel.requesting"/>): the channel type
     (org.freedesktop.Telepathy.Channel.Type.ContactList), the target handle
     type (either <type>Handle_Type_List</type> or
     <type>Handle_Type_Group</type>) and
     either a target handle retrieved by
     <methodname>RequestHandles</methodname> or the ID.
     <xref linkend="ex.channel.contactlist.ensurechannel"/> shows a code
     example.
    </para>
  
    <example id="example.channel.contactlist.examplemaps">
     <title>Example Maps For Requesting a Contact List</title>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
 	<entry>"subscribe"</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_Group</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </example>
    
    <example id="ex.channel.contactlist.ensurechannel"
             file="python_simple_presence/example.py">
     <title>Setting Up a Channel for a ContactList</title>
    </example>

    <para>
     Gaining access to the contacts listed in a contact list is actually
     achieved using the Channel's <interfacename>Group</interfacename>
     interface, which all <interfacename>ContactList</interfacename> objects
     implement. See <xref linkend="sect.channel.groups"/>.
    </para>

    <sect2 id="sect.channel.contactlist.server-defined">
     <title>Server Defined Lists</title>
     <para>
      A particular messaging protocol will likely provide a number of
      contact lists to a client, e.g. the list of subscribed contacts. These
      are the server defined lists (Handle_Type_List).
     </para>

     <para>
      Telepathy provides for several server-defined lists, but not all of
      them may be implemented by a given protocol, or even a given version
      of a protocol server. If you attempt to open a channel for a list that
      doesn't exists, an error will be returned. This error is not fatal, it
      simply means that list doesn't exist.
     </para>

     <para>
      Telepathy knows about the following server-defined lists:
     </para>

     <variablelist>
      <varlistentry><term>subscribe</term>
       <listitem><para>
        the group of contacts for whom you receive presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>publish</term>
       <listitem><para>
        the group of contacts who may receive your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>hide</term>
       <listitem><para>
        a group of contacts who are on the publish list but are temporarily
	disallowed from receiving your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>allow</term>
       <listitem><para>
        a group of contacts who may send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>deny</term>
       <listitem><para>
        a group of contacts who may not send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>stored</term>
       <listitem><para>
        on protocols where the user's contacts are stored, this contact list
	contains all stored contacts regardless of subscription status
       </para></listitem>
      </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="sect.channel.contactlist.user-defined">
     <title>User Defined Groups</title>

     <para>
      User-defined groups are the groups that a user places their contacts
      into. Not all protocols may support the concept of user-defined
      groups. In some protocols (e.g. XMPP) a contact may possibly be in
      more than one group.
     </para>

     <para>
      Channels will be set up for user-defined groups as they are discovered
      by the connection. Thus the currently configured groups can be
      discovered at any time by checking the <property>Channels</property>
      property or connecting to the <methodname>NewChannels</methodname>
      signal on the <interfacename>Requests</interfacename> interface
      (see <xref linkend="sect.channel.newchannels"/>).
     </para>

     <para>
      This returns a list of <type>Channel_Details</type>, which gives the
      channel object and a map of properties for the channel. This map
      always contains the properties
      <property>Channel.ChannelType</property>,
      <property>Channel.TargetHandleType</property>,
      <property>Channel.TargetHandle</property>,
      <property>Channel.TargetID</property>, and
      <property>Channel.Requested</property>.
      Filtering on <property>Channel.ChannelType</property> equals
      <interfacename>Channel.Type.ContactList</interfacename> and
      <property>Channel.TargetHandleType</property> equals
      <type>Handle_Type_Group</type> will yield the user-defined contact
      groups (demonstrated in
      <xref linkend="ex.channel.contactlist.user-defined.glib"/>).
     </para>

     <example id="ex.channel.contactlist.user-defined.glib"
              file="glib_get_user_defined_groups/example.c">
      <title>Filtering NewChannels</title>
     </example>
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.groups">
    <title>Contact Groups</title>

    <para>
     The <interfacename>Group</interfacename> interface is implemented by
     several channel types including contact list channels and multi-user
     chat channels.
    </para>

    <para>
     For any given group there may be current members, local pending members
     and remote pending members. These are respectively accessed via the
     <property>Members</property>, <property>LocalPendingMembers</property>
     and <property>RemotePendingMembers</property> D-Bus properties.
    </para>

    <para>
     <property>Members</property> is a list of handles of members who are
     currently part of this channel. This might be contacts in a contact list
     or participants in a multi-user chat. The
     <methodname>AddMembers</methodname> and
     <methodname>RemoveMembers</methodname> (or
     <methodname>RemoveMembersWithReason</methodname>) may be used to
     manipulate this list. Note that <methodname>AddMembers</methodname> may
     move a member onto the <property>RemotePendingMembers</property> list.
    </para>

    <para>
     <property>LocalPendingMembers</property> is a list of members who are
     pending the user's approval (e.g. to subscribe to your presence, join
     a chatroom, etc.). Members are approved using the
     <methodname>AddMembers</methodname> method, and declined using the
     <methodname>RemoveMembers</methodname> method.
     As well as handles, the <property>LocalPendingMembers</property>
     provides a handle to the actor that made the request and a reason for
     the change (which may be empty).
    </para>

    <para>
     <property>RemotePendingMembers</property> is a list of contacts who
     are pending another approval to be added to the channel (e.g. a remote
     user allowing subscription to their presence).
    </para>

    <note><para>
     If a person has multiple instant message accounts, for instance via
     different protocols, Telepathy has no way of knowing that these are
     actually the same person, and no way for your application to tell
     Telepathy this. Therefore, client applications should track this
     information if necessary.
    </para></note>

    <para>
     Information about a list of contacts can be looked up using the
     connection's <interfacename>Contacts</interfacename> interface. This
     is documented in <xref linkend="sect.contactinfo.contacts"/>.
    </para>

    <para>
     <xref linkend="ex.channel.groups.getting-members"/> shows how to
     retrieve a list of handles for current members of a group (in this case
     a contact list).
    </para>

    <example id="ex.channel.groups.getting-members"
             file="python_simple_presence/example.py">
     <title>Retrieving the Members of a Group</title>
    </example>
  
   <sect2 id="sect.channel.groups.glib">
    <title>telepathy-glib</title>

    <para>
     <application>telepathy-glib</application>'s
     <classname>TpChannel</classname> proxy provides a number of functions
     to access the group's members (if available). These can be made once
     the channel proxy has entered the ready state
     (see <xref linkend="sect.channel.requesting.glib"/>).
    </para>

    <para>
     The function <function>tp_channel_group_get_members</function> returns
     the set of contact handles stored in the <property>Members</property>
     property as a set of integer handles (<classname>TpIntSet</classname>).
     Similarly, the
     <function>tp_channel_group_get_local_pending</function> and
     <function>tp_channel_group_get_remote_pending</function> functions
     return the contact handles for <property>LocalPendingMembers</property>
     and <property>RemotePendingMembers</property> respectively. If the
     channel is not a <interfacename>Group</interfacename> these functions
     return <literal>NULL</literal>.
    </para>

    <tip>
     <para>
      See <xref linkend="sect.contactinfo.contacts.glib"/> for how to
      set up <classname>TpContact</classname> objects for each handle in
      a <interfacename>Group</interfacename>.
     </para>
    </tip>

    <para>
     The function
     <function>tp_channel_group_get_local_pending_info</function> is used to
     retrieve the additional information about a specific local pending
     contact: the actor handle, the reason and the message (the other
     entries of <type>Local_Pending_Info</type>).
    <!-- FIXME: example -->
    </para>

    <para>
     Rather than having to connect to the D-Bus signal,
     changes to the membership of the channel are signalled with the
     <methodname>group-members-changed</methodname> signal. This provides
     lists of members that have been added and removed along with a reason
     and an actor.
    </para>

   </sect2>

  </sect1>
  
  <sect1 id="sect.channel.text">
    <title>Text Channels</title>
    <indexterm><primary>Text</primary></indexterm>
  
    <para>
     A <interfacename>Text</interfacename> channel sends and receives text
     messages, such as instant
     messages. Each <interfacename>Text</interfacename> channel represents
     communication with a contact or group of contacts
     (e.g. a &quot;chat room&quot;).
    </para>

    <para>
     Channels for text chat are usually <emphasis>ensured</emphasis>
     (see <xref linkend="sect.channel.requesting"/>) with the channel type
     <type>Channel_Type_Text</type>. For one-to-one chats, the target handle
     is a contact (<type>Handle_Type_Contact</type>). For named chatrooms
     (e.g. Jabber multi-user-chats, IRC chatrooms) the target handle is a
     room (<type>Handle_Type_Room</type>); these channels should support the
     <interfacename>Group</interfacename> interface.
    </para>

    <para>
     Some protocols (e.g. MSN) support transient, unnamed chatrooms that
     are just defined by their members. These chatrooms are represented by
     an anonymous channel (<type>Handle_Type_None</type>) and
     implement the <interfacename>Group</interfacename> interface. On some
     protocols, i.e. ones where all chats are simply transient chatrooms,
     setting up a channel for a one-to-one chat with a contact may result
     in this type of channel; with the target contact simply a member.
    </para>

    <para>
     A summary of the various text channels is given in
     <xref linkend="table.channel.text.channels-summary"/>.
    </para>

    <table id="table.channel.text.channels-summary">
     <title>Summary of Text Channels</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Channel Function</entry>
	<entry>Example Usage</entry>
	<entry>Required Handle Type</entry>
	<entry>Required Interfaces</entry>
	<entry>Notes</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry>One-to-One Chat</entry>
	<entry>XMPP 1-1 chat, IRC private messages</entry>
	<entry><type>Handle_Type_Contact</type></entry>
	<entry></entry>
	<entry>
	 Requests for this sort of channel may be upgraded to a transient
	 chatroom.
        </entry>	
       </row>

       <row>
        <entry>Named Chatroom</entry>
	<entry>XMPP MUC, IRC chatroom</entry>
	<entry><type>Handle_Type_Room</type></entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry></entry>
       </row>

       <row>
        <entry>Transient Chatroom</entry>
	<entry>MSN conversation</entry>
	<entry><type>Handle_Type_None</type></entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry>Appears as an anonymous channel.</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

    <para>
     The <interfacename>Group</interfacename> interface present on
     chatroom-like channels is the same as that used for
     <interfacename>ContactList</interfacename>s, and is described in detail
     in <xref linkend="sect.channel.groups"/>.
    </para>

    <para>
     When the user wishes to part from a conversation, the channel's
     <methodname>Close</methodname> method should be called. The channel
     will be closed when the channel emits the
     <methodname>Closed</methodname> signal. Be aware that if there are
     still pending messages on the channel when it closes, a new, identical
     channel will be created by the connection (heralded by the
     <methodname>NewChannel</methodname> signal). This is to prevent message
     loss due to a possible race.
     <!-- FIXME: how does this fit into ChannelDispatcher -->
     For one-to-one chats, this is identical to when a remote user sends you
     a message.
    </para>

    <note>
     <title>Close vs. Destroy</title>
     <para>
      To prevent any possible message loss, closing a channel with pending
      messages using the <methodname>Close</methodname> method will cause a
      new, identical channel to respawn that is the continuation of the
      original channel.
     </para>
     <para>
      Occasionally this behaviour is undesireable/problematic. For example,
      when a particular text channel keeps crashing/causing errors in the
      message renderer. Closing the channel will cause it to respawn with
      the offending messages. In this case the
      <methodname>Destroy</methodname> method of the
      <interfacename>Destroyable</interfacename> interface can be used to
      ensure a channel is not respawned, dropping any pending messages on
      the channel.
     </para>
    </note>

    <para>
     Sending and receiving text messages in Empathy is documented in
     <xref linkend="chapter.messaging"/>.
    </para>

    <sect2 id="sect.channel.text.password">
     <title>Private Channels</title>

     <para>
      Some channels (usually chatrooms) require a password to be able to
      join them. Telepathy exposes this via the
      <interfacename>Password</interfacename> interface.
     </para>

     <para>
      Once a channel has been set up, and the interfaces retrieved, clients
      should check for the presence of the
      <interfacename>Password</interfacename> interface and if it exists
      call the <methodname>GetPasswordFlags</methodname> method. Telepathy
      currently has one flag: <type>Channel_Password_Flags_Provide</type>.
      If this flag is set, a password must be provided before the channel
      can be completely set up. Call the
      <methodname>ProvidePassword</methodname> method. If this returns true,
      then channel setup can continue.
     </para>

    </sect2>

    <sect2 id="sect.channel.text.muc">
     <title>Multi-User Chat</title>

     <para>
      Named Multi-user Chat (MUC) channels are represented by the
      <type>Handle_Type_Room</type> handle type. Like with contact
      identifiers, a room identifier depends on the protocol being used.
      <xref linkend="table.channel.text.muc.identifiers"/> presents some
      example identifiers for various protocols.
     </para>

     <table id="table.channel.text.muc.identifiers">
      <title>Example MUC Room Identifiers</title>
      <tgroup cols="2">
       <thead>
        <row>
	 <entry>Protocol</entry>
	 <entry>Example Room Identifer</entry>
        </row>
       </thead>
       <tbody>
        <row>
	 <entry>XMPP</entry>
	 <entry>telepathy@conference.xmpp.example.com</entry>
	</row>
	<row>
	 <entry>IRC</entry>
	 <entry>#telepathy</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.roomlist">
   <title>Room Lists</title>

   <para>
    The <interfacename>RoomList</interfacename> channel is used to access the
    available named chatrooms available on a server (e.g. XMPP multiuser
    chats, IRC chatrooms).
   </para>

   <para>
    <interfacename>RoomList</interfacename> channels are stateful, so
    they should be <emphasis>created</emphasis> (see
    <xref linkend="sect.channel.requesting"/>). On protocols that support
    multiple conference servers (e.g. XMPP), the <property>Server</property>
    property can be included in the request.
   </para>

   <para>
    <xref linkend="example.channel.roomlist.examplemap"/> shows an example
    property map that might be used to request a room list. Omitting the
    <property>Server</property> property will cause the server's default
    conference server to be used. If the server does not provide a default,
    the configured fallback for the connection will be used. If this is
    unset an error will occur (<errorname>NotAvailable</errorname>).
    <xref linkend="example.channel.roomlist.requestglib"/> shows a code
    example.
   </para>

   <note>
    <para>
     You can discover the default conferencing server by omitting the
     <property>Server</property> property and then reading the value on
     the newly created channel.
    </para>
   </note>
    
   <example id="example.channel.roomlist.examplemap">
    <title>Example Maps For Requesting a Room List</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Key</entry>
        <entry>Value</entry>
        <entry>Notes</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
        <entry>org.freedesktop.Telepathy.Channel.Type.RoomList</entry>
	<entry></entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
        <entry>Handle_Type_None</entry>
	<entry></entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.Type.RoomList.Server</entry>
	<entry>conference.xmpp.example.com</entry>
	<entry>Optional</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </example>

   <example id="example.channel.roomlist.requestglib"
            file="glib_jabber_muc/example.c">
    <title>Creating a RoomList Channel</title>
   </example>

   <important>
    <para>
     <interfacename>RoomList</interfacename> channels are anonymous. You
     must not provide a value for <property>TargetHandle</property> (unless
     you are using the deprecated <methodname>RequestChannel</methodname>
     method, in which case use the value <literal>0</literal>).
    </para>
   </important>
    
   <para>
    It can take some time for the information on the available rooms to be
    collected, thus the room list is returned via the
    <methodname>GotRooms</methodname> signal. Clients should connect this
    signal before calling <methodname>ListRooms</methodname>. See
    <xref linkend="example.channel.roomlist.listrooms"/>.
   </para>

   <para>
    The channel should be closed
    once it's finished with, so that the room handles
    (<type>Handle_Type_Room</type>) can be released.
   </para>

   <para>
    <methodname>GotRooms</methodname> returns a list of handles of type
    <type>Handle_Type_Room</type>, channel types (as D-Bus interfaces, e.g.
    <literal>org.freedesktop.Telepathy.Channel.Type.Text</literal> and
    property maps. Known keys in the property map are:
   </para>
    
    <informaltable>
     <tgroup cols="3">
      <tbody>
       <row>
        <entry>handle-name</entry>
	<entry>String</entry>
	<entry>
	 The name of the handle, as returned by
	 <methodname>InspectHandles</methodname>
        </entry>
       </row>
       <row>
        <entry>name</entry>
	<entry>String</entry>
	<entry>
	 The human readable name of the channel.
        </entry>	
       </row>
       <row>
        <entry>description</entry>
	<entry>String</entry>
	<entry>
	 The description of the room's purpose.
	</entry>
       </row>
       <row>
        <entry>subject</entry>
	<entry>String</entry>
	<entry>
	 The current subject or topic of conversation.
        </entry>
       </row>
       <row>
        <entry>members</entry>
	<entry>Unsigned integer</entry>
	<entry>
	 The number of members in the room.
	</entry>
       </row>
       <row>
        <entry>password</entry>
	<entry>Boolean</entry>
	<entry>
	 If a password is required for this channel.
	 See <xref linkend="sect.channel.text.password"/>.
        </entry>
       </row>
       <row>
        <entry>invite-only</entry>
	<entry>Boolean</entry>
	<entry>
	 If true, you must be invited to this channel.
	</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <example id="example.channel.roomlist.listrooms"
             file="python_irc_roomlist/example.py">
     <title>ListRooms</title>
    </example>

  </sect1>

</chapter>
