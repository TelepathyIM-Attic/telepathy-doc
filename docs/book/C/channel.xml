<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY mdash "&#8212;">
  <!ENTITY appversion "0.7">
  <!ENTITY manrevision "0.2">
  <!ENTITY date "12 August 2008">
  <!ENTITY app_no_markup "Telepathy">
  <!ENTITY app "<application>&app_no_markup;</application>">
  <!ENTITY url_examples_base "./examples/">
  <!ENTITY url_spec "http://telepathy.freedesktop.org/spec.html">
  <!ENTITY url_spec_base "&url_spec;#org.freedesktop.Telepathy.">
  <!ENTITY url_telepathy_glib_base "http://telepathy.freedesktop.org/doc/telepathy-glib/telepathy-glib-">
  <!ENTITY url_dbus_spec_base "http://dbus.freedesktop.org/doc/dbus-specification.html#">
  <!ENTITY url_dbus_glib_base "http://dbus.freedesktop.org/doc/dbus-glib/">
  <!ENTITY url_dbus_python_base "http://dbus.freedesktop.org/doc/dbus-python/api/">
]>

<chapter id="chapter.channel">
  <title>Channels</title>
  <para>
   Each <interfacename>Connection</interfacename> provides
   <interfacename>Channel</interfacename>s,
   which allow the local application to exchange data with the remote server,
   for instance to retrieve a list of contacts in a chat room, or to send a
   message to a contact.
  </para>
  <para>
   Channels always provide at least two D-Bus interfaces interfaces:
   <interfacename>org.freedesktop.telepathy.Channel</interfacename>,
   and another interface according to the type of channel it is (which can
   be retrieved using the <property>ChannelType</property> property).
   For instance, a text channel provides the
   <interfacename>org.freedesktop.telepathy.ChannelType.Text</interfacename>
   interface.
  </para>
  
  <para>
   The channel types currently available in Telepathy are:
  </para>
  <variablelist>

     <varlistentry>
       <term>
         <indexterm><primary>ContactList</primary></indexterm>
         <interfacename>ContactList</interfacename>
       </term>
       <listitem>
         <para>
	  This channel provides a list of people on the server, such as the
	  contacts to whose presence information you are subscribed or the
	  contacts to whom you publish your presence information.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.contactlist"/>.
	 </para>
       </listitem>
     </varlistentry>
     
     <varlistentry>
       <term>
         <indexterm><primary>RoomList</primary></indexterm>
         <interfacename>RoomList</interfacename>
       </term>
       <listitem>
         <para>
	  A channel type for listing named channels (e.g. chatrooms)
	  available on the server.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.roomlist"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>Text</primary></indexterm>
         <interfacename>Text</interfacename>
       </term>
       <listitem>
         <para>
	  This channel sends and receives plain text messages, such as instant
	  messages.
	 </para>
	 <para>
	  See <xref linkend="sect.channel.text"/>.
	 </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term>
         <indexterm><primary>StreamedMedia</primary></indexterm>
         <interfacename>StreamedMedia</interfacename>
       </term>
       <listitem>
         <para>
	  This channel sends and receives streamed audio or video,
	  such as a video call.
	 </para>
       </listitem>
     </varlistentry>
     
     <!--varlistentry>
       <term>
         <indexterm><primary>Tubes</primary></indexterm>
         <interfacename>Tubes</interfacename>
       </term>
       <listitem>
         <para>
	 </para>
       </listitem>
     </varlistentry-->
     
     <varlistentry>
       <term>
         <indexterm><primary>FileTransfer</primary></indexterm>
         <interfacename>FileTransfer</interfacename>
       </term>
       <listitem>
         <para>
	  A channel type for transferring files.
	 </para>
       </listitem>
     </varlistentry>

  </variablelist>
  
  <sect1 id="sect.channel.requesting">
    <title>Requesting Channels</title>

    <para>
     Channels are requested from a <classname>Connection</classname> object
     using the <interfacename>Requests</interfacename> interface.
    </para>

    <para>
     This interface provides two methods:
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname>.
     Both methods take the same parameter, a dictionary containing the
     desired properties for the channel.
    </para>

    <para>
     <methodname>CreateChannel</methodname> will attempt to create a new
     channel with the requested properties. Depending on the protocol, some
     types of channels are exclusive, and only one such channel can exist at
     a time (e.g. a XMPP chatroom). If a second channel is requested, the
     error <errorname>NotAvailable</errorname> is returned.
    </para>

    <para>
     Conversely, <methodname>EnsureChannel</methodname> will attempt to reuse an
     existing channel with the same properties wherever possible, else it
     will create a new channel. It's possible that another client is also
     utilising this channel. <!-- FIXME: write more on this -->
    </para>

    <tip>
     <title>When to Create and when to Ensure</title>
     <para>
      Choosing when to always create a new channel, or when to use an
      existing channel can usually be deduced based on the function of the
      channel. If it would make sense to reuse an existing channel then
      use <methodname>EnsureChannel</methodname>, otherwise use
      <methodname>CreateChannel</methodname>.
     </para>
     <para>
      <methodname>EnsureChannel</methodname> is usually used for
      <interfacename>Text</interfacename>,
      <interfacename>StreamedMedia</interfacename> and
      <interfacename>ContactList</interfacename> channels.
     </para>
     <para>
      <methodname>CreateChannel</methodname> is usually used for
      <interfacename>FileTransfer</interfacename>,
      <interfacename>Tubes</interfacename>,
      <interfacename>RoomList</interfacename> and
      <interfacename>ContactSearch</interfacename> channels.
     </para>
    </tip>

    <para>
     The properties argument for <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> is a map of property names on
     the desired channel, and their values.
     In general every channel requires at least three channel
     properties: the type of channel we wish to create
     (<property>ChannelType</property>), the handle/id of the contact/room/list
     we wish to create a channel for (<property>TargetHandle</property> or
     <property>TargetID</property>) and the type of that handle
     (<property>TargetHandleType</property>). Specific channel types may
     require additional properties in order to be created, this is noted in
     the specification.
    </para>

    <para>
     For example, to create a <interfacename>ContactList</interfacename>
     channel (this is the type of channel that is used to get a list of
     subscribed contacts from a service), we might provide a map like so:
    </para>

    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
	<entry>Handle_Type_List</entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
	<entry>"subscribe"</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

   <warning>
    <title>RequestChannel</title>
    <para>
     Some Connection Managers might not yet implement the
     <interfacename>Requests</interfacename> interface on their
     <classname>Connection</classname>s. In these cases you can
     use the <methodname>RequestChannel</methodname> method on the
     <interfacename>Connection</interfacename> interface, but you do so at
     your own risk.
    </para>
    <para>
     <methodname>CreateChannel</methodname> and
     <methodname>EnsureChannel</methodname> fix several flaws that were
     present in <methodname>RequestChannel</methodname>:
    </para>
    <itemizedlist>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't provide a way to insist
      on a new channel or prefer an existing channel;
     </para></listitem>
     <listitem><para>
      If <methodname>RequestChannel</methodname> returns an existing
      channel, the caller is not told whether the channel can be safely
      handled or if something else is handling it already;
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> can request a channel type,
      a handle type and a handle, but nothing more elaborate
      (e.g. you can't request a <interfacename>RoomList</interfacename>
      with a particular server); and
     </para></listitem>
     <listitem><para>
      <methodname>RequestChannel</methodname> doesn't return the channel's
      immutable properties (which is a useful optimization).
     </para></listitem>
    </itemizedlist>

    <para>
     If you must call <methodname>RequestChannel</methodname>, you call it
     with the same three arguments required for all channels (channel type,
     handle type and handle). The <parameter>Suppress_Handler</parameter>
     argument should <emphasis>always</emphasis> be True.
     <xref linkend="ex.channel.requestchannel"/> shows how to do this.
    </para>

    <example id="ex.channel.requestchannel"
             file="python_irc_roomlist/example.py">
     <title>Requesting a channel using RequestChannel</title>
    </example>
   </warning>

   <sect2 id="sect.channel.requesting.python">
    <title>telepathy-python</title>

    <para>
      telepathy-python provides the
      <classname>telepathy.client.Channel</classname> class as a D-Bus proxy
      object. To construct this proxy you need to pass the connection's
      D-Bus service name and the path to the channel object.
    </para>

    <para>
     <classname>telepathy.client.Channel</classname> can be inherited like
     any other Python class, so that you can pass around all of the methods
     and state relating to that channel as one object. This is shown in
     <xref linkend="ex.channel.requesting.python.class"/>.
    </para>

    <example id="ex.channel.requesting.python.class"
             file="python_iface_messaging/example.py">
     <title>Inheriting telepathy.client.Channel</title>
    </example>
   </sect2>
   
   <sect2 id="sect.channel.requesting.glib">
    <title>telepathy-glib</title>
    
    <para>
     Telepathy-glib provides the
     <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-create-channel"><function>tp_cli_connection_interface_requests_call_create_channel()</function></ulink>
     and <ulink url="&url_telepathy_glib_base;connection-requests.html#tp-cli-connection-interface-requests-call-ensure-channel"><function>tp_cli_connection_interface_requests_call_ensure_channel()</function></ulink>
     functions for this purpose.
    </para>

   </sect2>

  </sect1>

  <sect1 id="sect.channel.contactlist">
    <title>Contact Lists</title>
    <indexterm><primary>ContactList</primary></indexterm>
  
    <para>
     The <interfacename>ContactList</interfacename>
     channel type provides a list of people on the server, such as the contacts
     in a chat room, or the contacts to whose presence information you are
     subscribed.
    </para>
  
    <para>
     Like individual remote contacts themselves, lists of remote contacts
     is referred to by numeric
     <link linkend="sect.basics.handles">handle</link> of type
     <type>Handle_Type_List</type> (for
     <link linkend="sect.channel.contactlist.server-defined">server defined
     lists</link>) or
     <type>Handle_Type_Group</type> (for a
     <link linkend="sect.channel.contactlist.user-defined">user defined list of contacts</link>).
     The handle can be retrieved using the
     <methodname>RequestHandles</methodname> method on the Connection.
    </para>

    <para>
     To request a contact list, three properties must be provided to
     <methodname>EnsureChannel</methodname>
     (see <xref linkend="sect.channel.requesting"/>): the channel type
     (org.freedesktop.Telepathy.Channel.Type.ContactList), the target handle
     type (either <type>Handle_Type_List</type> or
     <type>Handle_Type_Group</type>) and
     either a target handle retrieved by
     <methodname>RequestHandles</methodname> or the ID.
     <xref linkend="ex.channel.contactlist.ensurechannel"/> shows a code
     example.
    </para>
  
    <example id="example.channel.contactlist.examplemaps">
     <title>Example Maps For Requesting a Contact List</title>
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetID</entry>
 	<entry>"subscribe"</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_List</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <informaltable>
      <tgroup cols="2">
       <tbody>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
 	<entry>org.freedesktop.Telepathy.Channel.Type.ContactList</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
 	<entry>Handle_Type_Group</entry>
        </row>
        <row>
         <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
 	<entry>&lt;handle&gt;</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </example>
    
    <example id="ex.channel.contactlist.ensurechannel"
             file="python_simple_presence/example.py">
     <title>Setting Up a Channel for a ContactList</title>
    </example>

    <para>
     Gaining access to the contacts listed in a contact list is actually
     achieved using the Channel's <interfacename>Group</interfacename>
     interface, which all <interfacename>ContactList</interfacename> objects
     implement. See <xref linkend="sect.channel.groups"/>.
    </para>

    <sect2 id="sect.channel.contactlist.server-defined">
     <title>Server Defined Lists</title>
     <para>
      A particular messaging protocol will likely provide a number of
      contact lists to a client, e.g. the list of subscribed contacts. These
      are the server defined lists (Handle_Type_List).
     </para>

     <para>
      Telepathy provides for several server-defined lists, but not all of
      them may be implemented by a given protocol, or even a given version
      of a protocol server. If you attempt to open a channel for a list that
      doesn't exists, an error will be returned. This error is not fatal, it
      simply means that list doesn't exist.
     </para>

     <para>
      Telepathy knows about the following server-defined lists:
     </para>

     <variablelist>
      <varlistentry><term>subscribe</term>
       <listitem><para>
        the group of contacts for whom you receive presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>publish</term>
       <listitem><para>
        the group of contacts who may receive your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>hide</term>
       <listitem><para>
        a group of contacts who are on the publish list but are temporarily
	disallowed from receiving your presence
       </para></listitem>
      </varlistentry>

      <varlistentry><term>allow</term>
       <listitem><para>
        a group of contacts who may send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>deny</term>
       <listitem><para>
        a group of contacts who may not send you messages
       </para></listitem>
      </varlistentry>

      <varlistentry><term>stored</term>
       <listitem><para>
        on protocols where the user's contacts are stored, this contact list
	contains all stored contacts regardless of subscription status
       </para></listitem>
      </varlistentry>

     </variablelist>
    </sect2>

    <sect2 id="sect.channel.contactlist.user-defined">
     <title>User Defined Groups</title>

     <para>
      User-defined groups are the groups that a user places their contacts
      into. Not all protocols may support the concept of user-defined
      groups. In some protocols (e.g. XMPP) a contact may possibly be in
      more than one group.
     </para>

     <para>
      Channels will be set up for user-defined groups as they are discovered
      by the connection. Thus the currently configured groups can be
      discovered at any time by checking the <property>Channels</property>
      property or connecting to the <methodname>NewChannels</methodname>
      signal on the <interfacename>Requests</interfacename> interface.
     </para>

     <para>
      This returns a list of <type>Channel_Details</type>, which gives the
      channel object and a map of properties for the channel. This map
      always contains the properties
      <property>Channel.ChannelType</property>,
      <property>Channel.TargetHandleType</property>,
      <property>Channel.TargetHandle</property>,
      <property>Channel.TargetID</property>, and
      <property>Channel.Requested</property>.
      Filtering on <property>Channel.ChannelType</property> equals
      <interfacename>Channel.Type.ContactList</interfacename> and
      <property>Channel.TargetHandleType</property> equals
      <type>Handle_Type_Group</type> will yield the user-defined contact
      groups.
     </para>
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.groups">
     <title>Contact Groups</title>
     <!--
     TODO:
     (used in lots of different channels)
     - This is partitioned into:
       - Current members
       - Local pending members, awaiting approval (by doing Add or Remove) by the 
         local user.
       - Remote pending members, awaiting approval remotely by the other user)
     - Unusually, one-to-one calls use the <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface to indicate call 
       progression (explain in call section?).
    -->
    <para>
     The <interfacename>Group</interfacename> interface is implemented by
     several channel types including contact list channels and multi-user
     chat channels.
    </para>

    <para>
     For any given group there may be current members, local pending members
     and remote pending members. These are respectively accessed via the
     <property>Members</property>, <property>LocalPendingMembers</property>
     and <property>RemotePendingMembers</property> D-Bus properties.
    </para>

    <para>
     <property>Members</property> is a list of handles of members who are
     currently part of this channel. This might be contacts in a contact list
     or participants in a multi-user chat. The
     <methodname>AddMembers</methodname> and
     <methodname>RemoveMembers</methodname> (or
     <methodname>RemoveMembersWithReason</methodname>) may be used to
     manipulate this list. Note that <methodname>AddMembers</methodname> may
     move a member onto the <property>RemotePendingMembers</property> list.
    </para>

    <para>
     <property>LocalPendingMembers</property> is a list of members who are
     pending the user's approval (e.g. to subscribe to your presence, join
     a chatroom, etc.). Members are approved using the
     <methodname>AddMembers</methodname> method, and declined using the
     <methodname>RemoveMembers</methodname> method.
     As well as handles, the <property>LocalPendingMembers</property>
     provides a handle to the actor that made the request and a reason for
     the change (which may be empty).
    </para>

    <para>
     <property>RemotePendingMembers</property> is a list of contacts who
     are pending another approval to be added to the channel (e.g. a remote
     user allowing subscription to their presence).
    </para>

    <note><para>
     If a person has multiple instant message accounts, for instance via
     different protocols, Telepathy has no way of knowing that these are
     actually the same person, and no way for your application to tell
     Telepathy this. Therefore, client applications should track this
     information if necessary.
    </para></note>

    <para>
     Information about a list of contacts can be looked up using the
     connection's <interfacename>Contacts</interfacename> interface. This
     is documented in <xref linkend="sect.contactinfo.contacts"/>.
    </para>

    <para>
     <xref linkend="ex.channel.groups.getting-members"/> shows how to
     retrieve a list of handles for current members of a group (in this case
     a contact list).
    </para>

    <example id="ex.channel.groups.getting-members"
             file="python_simple_presence/example.py">
     <title>Retrieving the Members of a Group</title>
    </example>
  
  </sect1>
  
  <sect1 id="sect.channel.text">
    <title>Text Channels</title>
    <indexterm><primary>Text</primary></indexterm>
  
    <para>
     A <interfacename>Text</interfacename> channel sends and receives text
     messages, such as instant
     messages. Each <interfacename>Text</interfacename> channel represents
     communication with a contact or group of contacts
     (e.g. a &quot;chat room&quot;).
    </para>

    <para>
     Channels for text chat are usually <emphasis>ensured</emphasis>
     (see <xref linkend="sect.channel.requesting"/>) with the channel type
     <type>Channel_Type_Text</type>. For one-to-one chats, the target handle
     is a contact (<type>Handle_Type_Contact</type>). For named chatrooms
     (e.g. Jabber multi-user-chats, IRC chatrooms) the target handle is a
     room (<type>Handle_Type_Room</type>); these channels should support the
     <interfacename>Group</interfacename> interface.
    </para>

    <para>
     Some protocols (e.g. MSN) support transient, unnamed chatrooms that
     are just defined by their members. These chatrooms are represented by
     an anonymous channel (<type>Handle_Type_None</type>, handle id 0) and
     implement the <interfacename>Group</interfacename> interface. On some
     protocols, i.e. ones where all chats are simply transient chatrooms,
     setting up a channel for a one-to-one chat with a contact may result
     in this type of channel; with the target contact simply a member.
    </para>

    <para>
     A summary of the various text channels is given in
     <xref linkend="table.channel.text.channels-summary"/>.
    </para>

    <table id="table.channel.text.channels-summary">
     <title>Summary of Text Channels</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Channel Function</entry>
	<entry>Example Usage</entry>
	<entry>Required Handle Type</entry>
	<entry>Required Interfaces</entry>
	<entry>Notes</entry>
       </row>
      </thead>
      <tbody>

       <row>
        <entry>One-to-One Chat</entry>
	<entry>XMPP 1-1 chat, IRC private messages</entry>
	<entry><type>Handle_Type_Contact</type></entry>
	<entry></entry>
	<entry>
	 Requests for this sort of channel may be upgraded to a transient
	 chatroom.
        </entry>	
       </row>

       <row>
        <entry>Named Chatroom</entry>
	<entry>XMPP MUC, IRC chatroom</entry>
	<entry><type>Handle_Type_Room</type></entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry></entry>
       </row>

       <row>
        <entry>Transient Chatroom</entry>
	<entry>MSN conversation</entry>
	<entry><type>Handle_Type_None</type></entry>
	<entry><interfacename>Group</interfacename></entry>
	<entry>Appears as an anonymous channel.</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

    <para>
     The <interfacename>Group</interfacename> interface present on
     chatroom-like channels is the same as that used for
     <interfacename>ContactList</interfacename>s, and is described in detail
     in <xref linkend="sect.channel.groups"/>.
    </para>

    <para>
     When the user wishes to part from a conversation, the channel's
     <methodname>Close</methodname> method should be called. The channel
     will be closed when the channel emits the
     <methodname>Closed</methodname> signal. Be aware that if there are
     still pending messages on the channel when it closes, a new, identical
     channel will be created by the connection (heralded by the
     <methodname>NewChannel</methodname> signal). This is to prevent message
     loss due to a possible race.
     <!-- FIXME: how does this fit into ChannelDispatcher -->
     For one-to-one chats, this is identical to when a remote user sends you
     a message.
    </para>

    <note>
     <title>Close vs. Destroy</title>
     <para>
      To prevent any possible message loss, closing a channel with pending
      messages using the <methodname>Close</methodname> method will cause a
      new, identical channel to respawn that is the continuation of the
      original channel.
     </para>
     <para>
      Occasionally this behaviour is undesireable/problematic. For example,
      when a particular text channel keeps crashing/causing errors in the
      message renderer. Closing the channel will cause it to respawn with
      the offending messages. In this case the
      <methodname>Destroy</methodname> method of the
      <interfacename>Destroyable</interfacename> interface can be used to
      ensure a channel is not respawned, dropping any pending messages on
      the channel.
     </para>
    </note>

    <sect2 id="sect.channel.text.password">
     <title>Private Channels</title>

     <para>
      Some channels (usually chatrooms) require a password to be able to
      join them. Telepathy exposes this via the
      <interfacename>Password</interfacename> interface.
     </para>

     <para>
      Once a channel has been set up, and the interfaces retrieved, clients
      should check for the presence of the
      <interfacename>Password</interfacename> interface and if it exists
      call the <methodname>GetPasswordFlags</methodname> method. Telepathy
      currently has one flag: <type>Channel_Password_Flags_Provide</type>.
      If this flag is set, a password must be provided before the channel
      can be completely set up. Call the
      <methodname>ProvidePassword</methodname> method. If this returns true,
      then channel setup can continue.
     </para>

    </sect2>
  
    <sect2 id="sect.channel.text.rich">
     <title>Rich Text Interface</title>

     <note>
      <para>
       The <interfacename>Messages</interfacename> interface is the
       preferred interface for text messaging, because it supports the full
       range of messaging features exposed by the protocols.
      </para>
      <para>
       Some older connection managers may not support this interface. If
       this is the case, or if you really only want to send simple messages
       (e.g. for a status reporting system), you can use the
       <link linkend="sect.channel.text.simple">simple messaging
       interface</link> documented below.
      </para>
     </note>

     <para>
      Telepathy provides support for rich-text messaging via the
      <interfacename>Messages</interfacename> interface. Rich-text messaging
      can include features like formatted (rich text) messages, alternatives
      (similar to MIME's multipart/alternative) and attachments. Messages
      are formatted in
      <ulink url="http://xmpp.org/extensions/xep-0071.html">XHTML-IM</ulink>.
     </para>

     <sect3 id="sect.channel.text.messages.format">
      <title>Message Structure</title>

      <para>
       Messages are sent and received as an array of
       <type>Message_Part</type> key-value mappings, the first of which
       contains the message headers.
       <xref linkend="ex.channel.text.rich.message-structure"/> shows an
       example message.
      </para>

      <example id="ex.channel.text.rich.message-structure">
       <title>Example Message</title>

       <para>
        An example message consisting of four <type>Message_Part</type>s:
	the headers, two alternatives and an attachment.
       </para>

       <informaltable>
        <tgroup cols="2">
	 <thead>
	  <row>
	   <entry>Key</entry>
	   <entry>Value</entry>
	  </row>
	 </thead>
	 <tbody>

	  <row>
	   <entry>message-token</entry>
	   <entry>"9de9546a-3400-4419-a505-3ea270cb834c"</entry>
	  </row>
	  <row>
	   <entry>message-sender</entry>
	   <entry>42</entry>
	  </row>
	  <row>
	   <entry>message-sent</entry>
	   <entry>1210067943</entry>
	  </row>
	  <row>
	   <entry>message-received</entry>
	   <entry>1210067947</entry>
	  </row>
	  <row>
	   <entry>message-type</entry>
	   <entry><type>Channel_Text_Message_Type_Normal</type></entry>
	  </row>
	  <row rowsep="1">
	   <entry>pending-message-id</entry>
	   <entry>437</entry>
	  </row>

	  <row>
	   <entry>alternative</entry>
	   <entry>"main"</entry>
	  </row>
	  <row>
	   <entry>content-type</entry>
	   <entry>"text/html"</entry>
	  </row>
	  <row rowsep="1">
	   <entry>content</entry>
	   <entry><![CDATA["""Here is a photo of my cat:<br /><img src="cid:catphoto" alt="lol!" /><br />Isn't it cute?"""]]></entry>
	  </row>

	  <row>
	   <entry>alternative</entry>
	   <entry>"main"</entry>
	  </row>
	  <row>
	   <entry>content-type</entry>
	   <entry>"text/plain"</entry>
	  </row>
	  <row rowsep="1">
	   <entry>content</entry>
	   <entry><![CDATA["""Here is a photo of my cat:\n[IMG: lol!]\nIsn't it cute?"""]]></entry>
	  </row>

	  <row>
	   <entry>identifier</entry>
	   <entry>"catphoto"</entry>
	  </row>
	  <row>
	   <entry>content-type</entry>
	   <entry>"image/jpeg"</entry>
	  </row>
	  <row>
	   <entry>size</entry>
	   <entry>101000</entry>
	  </row>
	  <row>
	   <entry>needs-retrieval</entry>
	   <entry>True</entry>
	  </row>

	 </tbody>
        </tgroup>	
       </informaltable>
      </example>

      <para>
       The known headers for a message are:
      </para>

      <informaltable>
       <tgroup cols="3">
        <thead>
	 <row>
	  <entry>Key</entry>
	  <entry>Type</entry>
	  <entry>Description</entry>
	 </row>
        </thead>

	<tbody>
	 <row>
          <entry>message-token</entry>
	  <entry>String</entry>
	  <entry>
	   An opaque, globally-unique identifier for the entire message. Which
	   may be treated the same as a MIME message-id for the mid: and cid:
	   URI schemes. Not always present.
	  </entry>
	 </row>

	 <row>
	  <entry>message-sent, message-received</entry>
	  <entry><type>Unix_Timestamp64</type></entry>
	  <entry>
	   The time the message was sent and received respectively. May not
	   be present if a time cannot be determined.
	  </entry>
	 </row>

	 <row>
	  <entry>message-sender</entry>
	  <entry><type>Contact_Handle</type></entry>
	  <entry>
	   The handle id of the contact who sent the message. May be 0 or
	   ommitted, if the sender cannot be determined.
	  </entry>
	 </row>

	 <row>
	  <entry>message-type</entry>
	  <entry><type>Channel_Text_Message_Type</type></entry>
	  <entry>
	   The type of message. Defaults to
	   <type>Channel_Text_Message_Type_Normal</type> if ommitted.
	  </entry>
	 </row>

	 <row>
	  <entry>pending-message-id</entry>
	  <entry><type>Message_ID</type></entry>
	  <entry>
	   The incoming message ID, only valid for as long as the message
	   is unacknowledged.

	   <important><para>
	    This header is important for acknowledging the received message.
	   </para></important>
	  </entry>
	 </row>

	 <row>
	  <entry>interface</entry>
	  <entry><type>DBus_Interface</type></entry>
	  <entry>
	   This message is specific to the given interface, which is neither
	   Text nor Messages. This key can also appear in subsequent
	   parts of the message.
	  </entry>
	 </row>

	 <row>
	  <entry>scrollback</entry>
	  <entry>Boolean</entry>
	  <entry>
	   If true, the incoming message was part of a replay of message
	   history. Defaults to false.
	  </entry>
	 </row>

	 <row>
	  <entry>rescued</entry>
	  <entry>Boolean</entry>
	  <entry>
	   If true, the incoming message has been seen in a previous channel
	   during the lifetime of the Connection, but had not been
	   acknowledged when that channel closed. Defaults to false.
	  </entry>
	 </row>

        </tbody>
       </tgroup>
      </informaltable>

      <para>
       Alternatives with the same name should be ordered from highest
       fidelity to lowest fidelity (i.e. rich text before plain text).
       Clients should display the first alternative they understand.
      </para>

     </sect3>

     <sect3 id="sect.channel.text.messages.receiving">
      <title>Receiving Messages</title>

      <para>
       When a remote user initiates a new text chat, Telepathy will
       automatically create a new channel for the chat, who's creation will
       be heralded by the <methodname>NewChannels</methodname> signal.
       Filter on the channels given for channels of type
       <type>Channel_Type_Text</type>.
       <xref linkend="ex.channel.text.messages.receiving.newchannels"/> shows
       how to discover this channel.
      </para>

      <example id="ex.channel.text.messages.receiving.newchannels"
               file="python_iface_messaging/example.py">
        <title>Discovering Incoming Channels</title>
      </example>

      <para>
       Set up a D-Bus proxy for the channel, like you would for any other
       channel (see <xref linkend="sect.channel.requesting"/>). Check to
       ensure that the <interfacename>Messages</interfacename> interface
       is available.
      </para>

      <para>
       Incoming messages are announced with the
       <methodname>MessageReceived</methodname> signal, which places them on
       the pending message queue. To remove messages from the pending
       message queue, they must be acknowledged with
       <methodname>Text.AcknowledgePendingMessages</methodname>. There will
       already be messages pending, the ones that caused the creation of
       the channel. These can be accessed via the
       <property>PendingMessages</property> property.
       See <xref linkend="ex.channel.text.messages.receiving.main"/>.
      </para>

      <para>
       The message id to acknowledge the message is contained in the headers
       of the message as the key <literal>pending-message-id</literal>
       (see <xref linkend="sect.channel.text.messages.format"/>).
      </para>
      
      <important>
       <title>Always Acknowledge Messages</title>
       <para>
        You must always acknowledge a received message, but you should only
	do so after you have attempted to parse it.
       </para>
       <para>
        Failure to acknowledge a message will result in a new channel
	being created with the pending messages when the current channel is
	closed.
       </para>
       <para>
        It's posssible that a bug in your application's message parser could
	cause an application crash.
        You should attempt to parse the message before acknowledging it.
	Thus, if your application has a crash, the message will still be
	pending when the client reloads.
       </para>
      </important>

      <example id="ex.channel.text.messages.receiving.main"
               file="python_iface_messaging/example.py">
        <title>Setting Up and Receiving Messages</title>
      </example>

     </sect3>

    </sect2>

    <sect2 id="sect.channel.text.simple">
     <title>Simple Messaging Interface</title>
      <para>
       Messages may be sent to the contact (or contact list) with the
       <methodname>Send</methodname>
       method. Sending messages can be requested using the Send method,
       which will return successfully. Other parts of your application may
       handle the <literal>Sent</literal> signal, for instance to log that
       side of the conversation.
      </para>
    
    </sect2>
  
  </sect1>

  <sect1 id="sect.channel.roomlist">
   <title>Room Lists</title>

   <para>
    The <interfacename>RoomList</interfacename> channel is used to access the
    available named chatrooms available on a server (e.g. XMPP multiuser
    chats, IRC chatrooms).
   </para>

   <para>
    <interfacename>RoomList</interfacename>s channels are stateful, so
    they should be <emphasis>created</emphasis> (see
    <xref linkend="sect.channel.requesting"/>). On protocols that support
    multiple conference servers (e.g. XMPP), the <property>Server</property>
    property can be included in the request.
   </para>
    
   <example id="example.channel.roomlist.examplemap">
    <title>Example Maps For Requesting a Room List</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Key</entry>
        <entry>Value</entry>
        <entry>Notes</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.ChannelType</entry>
        <entry>org.freedesktop.Telepathy.Channel.Type.RoomList</entry>
	<entry></entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandleType</entry>
        <entry>Handle_Type_None</entry>
	<entry></entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.TargetHandle</entry>
        <entry>0</entry>
	<entry></entry>
       </row>
       <row>
        <entry>org.freedesktop.Telepathy.Channel.Type.RoomList.Server</entry>
	<entry>conference.xmpp.example.com</entry>
	<entry>Optional</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </example>
    
   <para>
    It can take some time for the information on the available rooms to be
    collected, thus the room list is returned via the
    <methodname>GotRooms</methodname> signal. Clients should connect this
    signal before calling <methodname>ListRooms</methodname>.
   </para>

   <para>
    The channel should be closed
    once it's finished with, so that the room handles
    (<type>Handle_Type_Room</type>) can be released.
   </para>

   <para>
    <methodname>GotRooms</methodname> returns a list of handles of type
    <type>Handle_Type_Room</type>, channel types (as D-Bus interfaces, e.g.
    <literal>org.freedesktop.Telepathy.Channel.Type.Text</literal> and
    property maps. Known keys in the property map are:
   </para>
    
    <informaltable>
     <tgroup cols="3">
      <tbody>
       <row>
        <entry>handle-name</entry>
	<entry>String</entry>
	<entry>
	 The name of the handle, as returned by
	 <methodname>InspectHandles</methodname>
        </entry>
       </row>
       <row>
        <entry>name</entry>
	<entry>String</entry>
	<entry>
	 The human readable name of the channel.
        </entry>	
       </row>
       <row>
        <entry>description</entry>
	<entry>String</entry>
	<entry>
	 The description of the room's purpose.
	</entry>
       </row>
       <row>
        <entry>subject</entry>
	<entry>String</entry>
	<entry>
	 The current subject or topic of conversation.
        </entry>
       </row>
       <row>
        <entry>members</entry>
	<entry>Unsigned integer</entry>
	<entry>
	 The number of members in the room.
	</entry>
       </row>
       <row>
        <entry>password</entry>
	<entry>Boolean</entry>
	<entry>
	 If a password is required for this channel.
	 See <xref linkend="sect.channel.text.password"/>.
        </entry>
       </row>
       <row>
        <entry>invite-only</entry>
	<entry>Boolean</entry>
	<entry>
	 If true, you must be invited to this channel.
	</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

  </sect1>

</chapter>
