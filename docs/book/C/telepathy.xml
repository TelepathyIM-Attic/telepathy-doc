<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

  <!-- These entities are used in the generated .omf files, 
       along with the author tags,
       allowing the Yelp help browser to know about the document.
 
       The legal.xml file contains legal information, there is no need to edit the file. 
       Use the appversion entity to specify the version of the application.
       Use the manrevision entity to specify the revision number of this manual.
       Use the date entity to specify the release date of this manual.
       Use the app entity to specify the name of the application. -->
  <!ENTITY legal SYSTEM "legal.xml">
  <!ENTITY appversion "0.7">
  <!ENTITY manrevision "0.2">
  <!ENTITY date "12 August 2008">
  <!ENTITY app_no_markup "Telepathy">
  <!ENTITY app "<application>&app_no_markup;</application>">
  <!ENTITY url_examples_base "./examples/">
  <!ENTITY url_spec "http://telepathy.freedesktop.org/spec.html">
  <!ENTITY url_spec_base "&url_spec;#org.freedesktop.Telepathy.">
  <!ENTITY url_telepathy_glib_base "http://telepathy.freedesktop.org/doc/telepathy-glib/telepathy-glib-">
  <!ENTITY url_dbus_spec_base "http://dbus.freedesktop.org/doc/dbus-specification.html#">
  <!ENTITY url_dbus_glib_base "http://dbus.freedesktop.org/doc/dbus-glib/">
  <!ENTITY url_dbus_python_base "http://dbus.freedesktop.org/doc/dbus-python/api/">
]>

<book id="index">
  <bookinfo>
    <title>&app; manual</title>

    <!-- If we were using the FDL license then we would need full revision 
         tags instead of just this one date.
         Actually, it seems that DocBook allows just a single date tag without 
         these revhistory tags, but maybe gnome-doc-utils cannot cope with 
         that. -->
    <revhistory>
      <revision> 
        <revnumber>&app_no_markup; &appversion;</revnumber> 
          <date>&date;</date> 
          <revdescription> 
            <para role="author">Murray Cumming</para> 
            <para role="publisher">&app;</para> 
	  </revdescription> 
      </revision>
    </revhistory> 

    <authorgroup>
      <author role="maintainer"> 
        <firstname>Murray</firstname> 
        <surname>Cumming</surname> 
        <affiliation> 
          <orgname>&app_no_markup; Documentation Team</orgname> 
          <address> <email>murrayc@openismus.com</email> </address> 
        </affiliation> 
      </author> 
      <author>
        <firstname>Davyd</firstname>
        <surname>Madeley</surname>
        <affiliation>
          <orgname>Collabora Ltd.</orgname>
          <address> <email>davyd.madeley@collabora.co.uk</email> </address>
        </affiliation>
      </author>
    </authorgroup>
      

    <copyright>
      <year>2008-9</year>
      <holder>Collabora Ltd</holder>
    </copyright>

    <abstract role="description">
      <para>Software development manual for &app;.</para>
    </abstract>


  <xi:include href="legal.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

  </bookinfo>
      
<chapter id="chapter-introduction">
  <title>Introduction</title>
  <!--
  <para>The Telepathy framework allows applications to use real-time communications via several common protocols, such as XMPP (Jabber). For instance, an instant messenger application might use Telepathy to allow chats with online contacts via accounts with various IM services. Or a  game might use Telepathy to simplify the implementation of its networking code, allowing users to play against each other.</para>
  <para>Telepathy is a <ulink url="http://www.freedesktop.org/wiki/Software/dbus">D-Bus</ulink> API so it may be used from most programming languages.</para>
  <para>All this functionality is available under an open source license, allowing people to make improvements and add new features.</para>

  <para>TODO:  What are the benefits? How is it better than the alternatives? (If there are any). Is it easier, robuster, more secure, more flexible, cheaper, free-er, what?</para>
  -->
  <para>
   Telepathy is a flexible, modular communications framework that enables
   real-time communication via pluggable protocol backends. Telepathy
   creates the idea of communication as a desktop service. It
   uses
   <ulink url="http://www.freedesktop.org/wiki/Software/dbus">D-Bus</ulink>
   to separate components running in separate processes. Telepathy clients
   use this D-Bus API (usually via a convenience library &mdash; e.g.
   telepathy-glib) to share connections between multiple clients (e.g. an
   instant messaging program, presence in email application, collaboration
   in word processor).
  </para>

  <note>
   <title>Do One Thing and Do It Well</title>
    <blockquote>
     <attribution>Doug McIlroy</attribution>
     <para>
      This is the Unix philosophy: Write programs that do one thing and do it
      well. Write programs to work together.
     </para>
    </blockquote>
   <para>
    Telepathy components are modular, this means that developers can focus
    on making each component being the best it can be.
   </para>
   <para>
    Application developers can focus on user interaction whilst protocol
    developers can focus on an individual protocol.
   </para>
  </note>

  <figure id="fig.introduction.telepathy-architecture-overview">
   <title>
    Conceptual example of Telepathy clients (blue) and
    Connection Managers (green)
   </title>
   <mediaobject><imageobject>
    <imagedata fileref="figures/telepathy-architecture-overview.png"
               format="PNG" />
   </imageobject></mediaobject>
  </figure>
   
  <para>
   Backends for
   many popular instant messaging protocols already exist including
   XMPP/Jabber (telepathy-gabble), SIP (telepathy-sofiasip), MSN
   (telepathy-butterfly) and IRC (telepathy-idle). The development of a
   new protocol backend can be utilised immediately by all Telepathy consumers.
  </para>

  <para>
   Telepathy backends can expose the different features of a communications
   protocol, including presence (status), text chat (instant messaging),
   voice and video conferencing, file transfer and
   Tubes (contact-to-contact network sockets brokered by Telepathy); and do
   this in a unified way via D-Bus interfaces.
  </para>

  <note>
   <title>Is Telepathy a Specification or an Implementation?</title>
   <para>
    It's both.
   </para>
   <para>
    There is one
    <ulink url="http://telepathy.freedesktop.org/spec.html">specification</ulink>
    which defines the D-Bus API for how one Telepathy component talks to
    another. Additionally there are many implementations of this
    specification in the form of libraries that wrap the D-Bus API in a
    model that might be more familiar to you; and components (e.g. the
    Connection Managers) that allow you to do useful things with Telepathy.
   </para>
  </note>

  <sect1>
   <title>Rationale</title>
   <!-- much of this was crimed from
        http://telepathy.freedesktop.org/wiki/Rationale -->
   <para>
    The design of Telepathy, and its approach to real-time communications
    comes from a very specific rationale:
   </para>
   <itemizedlist>
     <listitem><para>
       <emphasis>Robustness:</emphasis>
       one component can crash without crashing others.
     </para></listitem>
     <listitem><para>
       <emphasis>Ease of development:</emphasis>
       components can be replaced within a running system; tools like
       dbus-inspector can trace interactions between components.
     </para></listitem>
     <listitem><para>
       <emphasis>Language independence:</emphasis>
       components can be written in any language that has a D-Bus binding;
       if the best free and open implementation of a given communications
       protocol is in a certain language, you are able to write your
       Connection Manager in that language and still have it available to
       all Telepathy clients.
     </para></listitem>
     <listitem><para>
       <emphasis>Desktop independence:</emphasis>
       D-Bus has been adopted by both GNOME and KDE. Multiple user
       interfaces can be developed on top of the same Telepathy components.
     </para></listitem>
     <listitem><para>
       <emphasis>License independence:</emphasis>
       Components can be under different licenses that would be incompatible
       if all components were running in one process.
     </para></listitem>
     <listitem><para>
       <emphasis>Code reuse:</emphasis>
       Telepathy allows clients to ignore protocol details as much as
       possible, easing transitions between different communications
       systems.
     </para></listitem>
     <listitem><para>
       <emphasis>Connection reuse:</emphasis>
       Multiple Telepathy clients can use the same connection simultaneously.
     </para></listitem>
     <listitem><para>
       <emphasis>Security:</emphasis>
       Components can run with very limited privileges; a typical connection
       manager only needs access to the network and to the D-Bus session bus
       (e.g. making it possible to use an SELinux policy to prevent protocol
       code from accessing the disk).
     </para></listitem>
   </itemizedlist>
  </sect1>
</chapter>

<chapter id="chapter-installation">
  <title>Installation</title>
  <para>If you are using a common Linux distribution you may already have the Telepathy packages installed. For instance, it is a dependency of the <application>Empathy</application> instant messenging client. However, you will probably still need some extra packages to build the examples in this book.</para>
  
  <sect1>
    <title>Installation on Ubuntu Linux</title>
    <para>You can install the Telepathy packages from the command line <application>Terminal</application> with this command: <command>sudo apt-get install telepathy-devel libtelepathy-glib-dev</command></para>
  </sect1>

  <sect1>
    <title>Installation on Fedora Linux</title>
     <!-- TODO: Is there no general telepathy-devel package? -->
     <para>You can install the Telepathy packages from the command line <application>Terminal</application> with this command, as root: <command>yum install telepathy-glib-devel telepathy-gabble telepathty-butterfly telepathy-haze telepathy-salut telepathy-stream-engine</command></para>
  </sect1>

  <sect1>
    <title>Building from Source</title>
    
    <sect2>
     <title>Getting the Source</title>

       <sect3>
         <title>Released Versions</title>
	 <para>
	   Releases of Telepathy components are made available as tarballs
	   on the
	   <ulink url="http://telepathy.freedesktop.org/releases/">Telepathy
	   website</ulink>.
	 </para>
       </sect3>

       <sect3>
         <title>From Git</title>
	 <para>
	   Telepathy uses Git for revision control.
	   XXX WRITE MORE ABOUT THIS
	 </para>
       </sect3>

    </sect2>
  </sect1>

</chapter>

<!--
Notes:
- The following sections describe important D-Bus API in telepathy.
These sections will describe how these interfaces can be used, including small 
code snippets.
- Where possible the documentation will pull in small but complete 
code examples which can build as part of the documentation, guaranteeing that 
they at least compile with the latest API, and making it easier to test that 
they really work.
- Wherever interfaces are mentioned, there will be a links to online API 
reference documentation (assuming that it exists) and links to relevant parts 
of the Telapathy specification. 
-->

<chapter id="chapter-basics">
  <title>Basics</title>

  <para>This chapter introduces some basic techniques and concepts that you must understand to use Telepathy confidently. You should read through this chapter before proceeding, but you will probably want to refer back here again later.</para>

  <sect1>
   <title>Terminology</title>
   <para>
    This section aims to be a glossary of the different terms you will
    encounter in Telepathy. Each of these concepts is explained in more
    detail later in the manual.
   </para>

   <para>
    The design of Telepathy is heavily influenced by D-Bus, so much of its
    terminology is shared in common with D-Bus. For those unfamiliar with
    D-Bus, a quick primer is presented in <xref linkend="sec-basics-dbus"/>.
    For more indepth information, consult A MANUAL THAT PROBABLY HASN'T BEEN
    WRITTEN YET.<!-- FIXME -->
   </para>

   <!-- FIXME: what order do these go in? -->
   <!-- FIXME: some of this information is too detailed for this glossary
               and should be moved further down the manual -->
   <sect2>
    <title>Connection Manager</title>
    <para>
     Connection managers are simply factories for connections; new
     connections are created using the
     <methodname>RequestConnection</methodname> method on the
     <!-- FIXME - link to spec ? -->
     <interface>org.freedesktop.Telepathy.ConnectionManager</interface>
     interface.
    </para>
    <para>
     The term
     “connection manager” is often used to mean the process that provides
     the connection manager service. Each connection has its own D-Bus
     service name (e.g.
     <literal>org.freedesktop.Telepathy.ConnectionManager.gabble</literal>),
     but it's common for the connection manager service to run
     in the same process as its connections. It's also common for the
     connection manager object to provide only the main connection manager
     interface (the common D-Bus introspection and properties interfaces
     excepted).
    </para>
    <para>
     Connection managers are typically started via D-Bus service activation,
     when a Telepathy application would like to create a new connection.
    </para>
    <para>
     Connection managers are discussed in more detail in
     <xref linkend="chapter-connection-manager"/>.
    </para>
   </sect2>

   <sect2>
    <title>Connection</title>
    <para>
     Connections represent active protocol sessions. A connection has a set
     of parameters that it is requested with. Although the parameters used
     vary from protocol to protocol, some parameter names have a standard
     meaning. A notable example is the account parameter, used to specify a
     persistent identity, usually stored on a server. Some protocols,
     however, do not have accounts, in which case the account parameter will
     be absent.
    </para>
    <para>
     The connection interface (org.freedesktop.Telepathy.Connection) is
     mainly concerned with the management of handles and channels. It's
     common for connections to have a number of other interfaces, such as
     the aliasing, avatars and presence interfaces.
    </para>
    <para>
     Connection objects cease to exist when the Disconnect method is called.
     If the connection wasn't already in the Disconnected state, a
     StatusChanged signal is emitted.
    </para>
   </sect2>

   <sect2>
    <title>Channel</title>
    <para>
     Channels are created using a connection's RequestChannel method, or are
     created by the connection manager in response to communication
     initiated by someone else, in which case their advent is heralded by
     the NewChannel signal.
    </para>
    <para>
     Channels always provide at least two interfaces:
     org.freedesktop.telepathy.Channel, and another interface according to
     which type of channel it is. For instance, a text channel provides the
     org.freedesktop.telepathy.ChannelType.Text interface.
    </para>
   </sect2>

   <sect2>
    <title>Handle</title>
    <para>
     Handles are used to represent various kinds of protocol resources. Each
     handle has an associated string identifier. Handles are used to avoid
     normalisation problems: by having the connection be responsible for
     mapping equivalent resource identifiers to the same handle, Telepathy
     clients need only compare handles for integer equality. For instance,
     protocol X might consider the identifiers foobar@example.com and
     fooBaR@example.com equivalent, in which case a connection speaking
     protocol X, when asked to convert both into handles, would return the
     same handle for both.
    </para>
    <para>
     The handle 0 is never a valid handle, but may be used in the API to
     indicate a special case.
    </para>
    <para>
     Handles can be generated explicitly, using the RequestHandles method,
     in which case the client owns a reference to those handles. The
     reference can be relinquished using ReleaseHandles. In other cases, the
     connection manager might generate handles implicitly, in which case
     clients can obtain a reference using HoldHandles. Each client can only
     obtain one reference to each handle; referencing a handle multiple
     times is idempotent. A client's references are automatically released
     when it exits.
    </para>
    <para>
     Handles cease to exist when they have no implicit references (e.g. from
     a channel that they are related to) and no explicit references from
     clients.
    </para>
   </sect2>

   <sect2>
    <title>Interface</title>
    <para>
    </para>
   </sect2>
  </sect1>

  <sect1 id="sec-basics-dbus">
    <title>Using D-Bus</title>
    <para>Telepathy is a <indexterm><primary>D-Bus</primary></indexterm>D-Bus API. Telepathy components conform to the <ulink url="&url_spec;">Telepathy D-Bus Specification</ulink>, which is therefore also the main Telepathy API reference.</para>
    <para>D-Bus is an <indexterm><primary>IPC</primary></indexterm>IPC (Inter-process communication) system, allowing different software components to be implemented in different processes, with different programming languages. It also allows multiple applications to easily share functionality from a single process. Most examples in this book will use <link linkend="sec-basics-language-bindings">language bindings</link> instead of using D-Bus directly. However, an understanding of the following D-Bus concepts will help you even when using language bindings.</para>
 
    <figure id="fig.basics.dbus.conceptual">
     <title>
      Programs connected to a D-Bus Bus
     </title>
     <mediaobject><imageobject>
      <imagedata fileref="figures/bus-conceptual.png"
                 format="PNG" />
     </imageobject></mediaobject>
    </figure>

     <variablelist>

       <varlistentry>
         <term>
	   <indexterm><primary>Unique Name</primary></indexterm>
	   Unique Name
	 </term>
	 <listitem>
	   <para>
	     This is an identifier assigned to a client by the D-Bus daemon
	     (e.g. :1.3). Every client on the D-Bus has one, whether or not
	     it is offering a named service.
	     It is an analagous to an IP address in computer networking.
	   </para>
	 </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>Bus Name</primary></indexterm>
           Bus Name
         </term>
	 <!-- FIXME - what's the correct markup for bus names, etc? -->
         <listitem>
           <para>
	     A process can make a service available by connecting to a
	     D-Bus <literal>bus</literal> and requesting a
	     &quot;well-known&quot; <literal>bus name</literal> for the
	     connection, by which other processes, such as applications, can
	     access it.
	     If unique names are analagous to IP addresses, then
	     bus names are like a DNS name.
	   </para>
	   <para>
	     The example in
	     <xref linkend="fig.basics.dbus.hierarchy-conceptual"/> provides
	     the well-known bus name &quot;org.freedesktop.foo.Foo&quot;.
	   </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>Object Path</primary></indexterm>
           Object Path
         </term>
         <listitem>
           <para>
	     The service process provides D-Bus objects on that bus name.
	     Each object has an <literal>object path</literal>, such as
	     &quot;/org/freedesktop/foo/jack&quot;
	     (<xref linkend="fig.basics.dbus.hierarchy-conceptual"/>),
	     which a client application must specify to use that object.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>Interface Name</primary></indexterm>
           Interface Name
         </term>
         <listitem>
           <para>Each D-Bus object implements one or more D-Bus interfaces.
	   Each interface has an <literal>interface name</literal>, such as
	   &quot;org.freedesktop.foo.Jack&quot;
	   (<xref linkend="fig.basics.dbus.hierarchy-conceptual"/>).
	   Each interface provides one
	   or more methods or signals, each with a member name.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
	   <indexterm><primary>Method</primary></indexterm>
	   Method
	 </term>
	 <listitem>
	   <para>
	     A D-Bus interface can expose a number of methods that can be
	     called by a client. They have parameters and return types that
	     are given as a D-Bus type signature.
	   </para>
	   <para>
	    <xref linkend="fig.basics.dbus.hierarchy-conceptual"/> gives the
	    example of the &quot;Fetch&quot; method (telling Jack to fetch a
	    pail of water).
	   </para>
	 </listitem>
       </varlistentry>

       <varlistentry>
         <term>
	   <indexterm><primary>Signal</primary></indexterm>
	   Signal
	 </term>
	 <listitem>
	   <para>
	     A D-Bus interface can also expose a number of signals that can be
	     connected to by a client. Connecting a signal involves
	     providing a callback that matches the signal's type signature
	     that can be called by the mainloop (unlike
	     UNIX signals, D-Bus signals are not asynchronous).
	   </para>
	   <para>
	    <xref linkend="fig.basics.dbus.hierarchy-conceptual"/> gives the
	    example of the &quot;Broken&quot; signal (which is triggered
	    when Jack falls down and breaks his crown).
	   </para>
	 </listitem>
       </varlistentry>

       <varlistentry>
         <term>
	   <indexterm><primary>Property</primary></indexterm>
	   Property
	 </term>
	 <listitem>
	   <para>
	     D-Bus objects implementing the org.freedesktop.DBus.Properties
	     interface may also expose typed properties.
	   </para>
	 </listitem>
       </varlistentry>

    </variablelist>
    
    <figure id="fig.basics.dbus.hierarchy-conceptual">
     <title>
      Methods and signals on an object
     </title>
     <mediaobject><imageobject>
      <imagedata fileref="figures/bus-hierarchy-conceptual.png"
                 format="PNG" />
     </imageobject></mediaobject>
    </figure>

    <tip>
     <title>Naming in D-Bus</title>
     <para>
      A D-Bus bus is shared with lots of other clients and services, some of
      which will not have been thought of yet. It is important to ensure
      that your well-known names, objects and interfaces all have unique
      names.
     </para>
     <para>
      When choosing a bus name, object name or interface name
      it is best practice to use your domain name reversed (as
      is done for Java packages) to avoid possible conflicts.
     </para>
     <para>
      For example for bus names or interfaces:
     </para>
     <itemizedlist>
      <listitem><para>org.freedesktop.Telepathy.ConnectionManager</para></listitem>
      <listitem><para>org.gnome.Project</para></listitem>
      <listitem><para>com.mycompany.MyProduct</para></listitem>
     </itemizedlist>
     <para>
      For objects:
     </para>
     <itemizedlist>
      <listitem><para>/org/freedesktop/Telepathy/ConnectionManager/gabble</para></listitem>
      <listitem><para>/org/gnome/Project/adaptor</para></listitem>
      <listitem><para>/com/mycompany/MyProduct/object0</para></listitem>
     </itemizedlist>
    </tip>

    <para>Of course, for simple services with just one object that provides just one interface, these three names will often look very similar.</para>

    <para>In the following sections you will see how a D-Bus API can be used from some common programming languages. Remember that these examples only create <literal>proxies</literal> to the D-Bus objects, providing a way to use their API. The actual objects are instantiated in the service's process.</para>

    <para>In these examples, we use the FreeDesktop <literal>Notification</literal> system, which should be available on most modern Linux installations. The examples should cause a message to popup from your desktop panel. Note that, like Telepathy, this service is available on the <indexterm><primary>Session Bus</primary></indexterm><literal>Session Bus</literal> rather than the <indexterm><primary>System Bus</primary></indexterm><literal>System Bus</literal>. Services on the <literal>Session Bus</literal> are for the current user's session only. Services on the <literal>System Bus</literal> are shared between all users.</para>

<!--
    <para>These programming languages allow you to call D-Bus methods synchronously, meaning that they block until they can return the method's result. However, that is generally disapproved of because the D-Bus service may take a long time to reply, and because of some fundamental technical problems with the use of blocking calls between processes. Therefore, the examples call the D-Bus method asynchronously, theoretically allowing the application to continue with other tasks while waiting for the result.</para> 
-->
    <!-- TODO: Get the result asynchronously. --> 
    <warning id="warning.dbus.sync">
      <title>Always Avoid Synchronous D-Bus Calls</title>
      <!-- this information came from
      http://smcv.pseudorandom.co.uk/2008/11/nonblocking/ -->

      <para>
        The <ulink
	url="http://dbus.freedesktop.org/doc/dbus-specification.html">D-Bus
	specification</ulink> defines D-Bus as an asynchronous
	message-passing system, and provides no mechanism for blocking calls
	at the protocol level. However <literal>libdbus</literal> and most
	D-Bus bindings (dbus-glib, dbus-python and QtDBus) provide a
	&quot;blocking&quot; API
	(<function>dbus_do_something_and_block</function>) that implements a
	&quot;pseudo-blocking&quot; behaviour. In this mode only the D-Bus
	socket is polled for new I/O and any D-Bus messages that are not the
	reply to the original message are put on a queue for later
	processing once the reply has been received.
      </para>

      <para>
       This causes several major problems:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         Messages can be reordered. Any message received before the reply and
	 placed on the queue will be delivered to the client after the reply,
	 which violates the ordering guarentee the D-Bus daemon provides.
        </para>
        <para>
	 This can cause practical problems where a signal indicating an
	 object's destruction is delayed. The client gets a method reply
	 &quot;UnknownMethod&quot; and doesn't know why until the signal is
	 delivered with more information.
        </para>
       </listitem>
       <listitem><para>
        The client is completely unresponsive until the service replies
	(include the user interface). If the service you're calling into has
	locked up (this can happen, even in services that are designed to be
	purely non-blocking and asynchronous), the client will be
	unresponsive for 25 seconds until the call times out.
       </para></listitem>
       <listitem><para>
        The client cannot parallelize calls &mdash; if a signal causes
	method calls to be made, a client that uses pseudo-blocking calls
	can't start processing the next message until those method calls
	return.
       </para></listitem>
       <listitem>
        <para>
         If two processes make pseudo-blocking calls on each other, a
	 deadlock occurs.
        </para>
	<para>
	 This sort of scenario occurs with plugin architectures and shared
	 D-Bus connections. One plugin "knows" it's a client, not a service;
	 and another plugin, shaing the same connection, "knows" it's a
	 service, not a client. This results in a process that is both a
	 service and a client (and hence deadlock-prone).
	</para>
       </listitem>
      </itemizedlist>
    </warning>

    <tip>
     <title>Introspecting a Bus</title>
     <para>
      Many services on a D-Bus bus provide a mechanism to introspect their
      available objects and associated interfaces. A good utility for doing
      this in an interactive way is
      <ulink url="https://fedorahosted.org/d-feet/">D-Feet</ulink>.
     </para>
     <figure id="fig.dbus.d-feet">
      <title>
       D-Feet D-Bus Introspection Tool
      </title>
      <mediaobject><imageobject>
       <imagedata fileref="figures/dfeet-dbus-introspection-tool.png"
                  format="PNG" />
      </imageobject></mediaobject>
     </figure>
     <para>
      D-Feet shows each service connected to the bus and the objects,
      interfaces, methods and signals available for that service.
      It allows (synchronous) method calls to be made.
     </para>
    </tip>

    <sect2 id="sec-basics-dbus-glib">
      <title>Using D-Bus from C, with glib</title>

      <sect3 id="sect-basics-dbus-glib-methods">
        <title>Calling Methods</title>
        <para>This example uses dbus-glib's <ulink url="&url_dbus_glib_base;dbus-glib-DBusGProxy.html#dbus-g-proxy-begin-call"><function>dbus_g_proxy_begin_call()</function></ulink> function to call the <literal>Notify()</literal> method on the <literal>org.freedesktop.Notification</literal> interface of the desktop notification service at the <literal>/org/freedesktop/Notification</literal> path. Note that we must specify the types of each parameter. The specified callback function then calls <ulink url="&url_dbus_glib_base;dbus-glib-DBusGProxy.html#dbus-g-proxy-end-call"><function>dbus_g_proxy_end_call()</function></ulink> to retreive the result.</para>
        <para>We could have used the synchronous <ulink url="&url_dbus_glib_base;dbus-glib-DBusGProxy.html#dbus-g-proxy-call"><function>dbus_g_proxy_call()</function></ulink> function instead but, as already mentioned, asynchronous calls are generally preferred with D-Bus.</para>
        <para><ulink url="&url_examples_base;basics_dbus_glib_methods">Source Code</ulink></para>
      </sect3>

     <sect3 id="sect-basics-dbus-glib-properties">
        <title>Using Properties</title>
        <para>D-Bus properties are available via an additional <ulink url="&url_dbus_spec_base;standard-interfaces-properties">org.freedesktop.DBus.Properties</ulink> interface on some objects, which provides <methodname>Get()</methodname>, <methodname>Set()</methodname> and <methodname>GetAll</methodname> methods. You can call these methods to get or set property values for the object's other interfaces.</para>
        <para>As of this writing, telepathy-glib has no simple API for dealing with properties so you must call these functions directly. Therefore this example is therefore very similar to the <link linkend="sect-basics-dbus-glib-methods">Calling Methods</link> example.</para>
        <para><ulink url="&url_examples_base;basics_dbus_glib_properties">Source Code</ulink></para>
      </sect3>

      <sect3 id="sect-basics-dbus-glib-signals">
        <title>Handling Signals</title>
        <para>D-Bus signal handlers may be specified with dbus-glib with the <ulink url="&url_dbus_glib_base;dbus-glib-DBusGProxy.html#dbus-g-proxy-connect-signal"><function>dbus_g_proxy_connect_signal()</function></ulink> function. As when calling D-Bus methods, you must specify the expected types, but for signals you must do this in a previous call to <ulink url="&url_dbus_glib_base;dbus-glib-DBusGProxy.html#dbus-g-proxy-add-signal"><function>dbus_g_proxy_add_signal()</function></ulink>. The specified callback function will then be called when the signal is emitted. This example connects to the &quot;DeviceAdded&quot; signal of the &quot;org.freedesktop.Hal.Manager&quot; interface so it can print a message to the terminal when, for instance, you plug in a USB stick.</para>
        <para><ulink url="&url_examples_base;basics_dbus_glib_signals">Source Code</ulink></para>
      </sect3>

    </sect2>

    <sect2 id="sec-basics-dbus-python">
      <title>Using D-Bus from Python</title>

      <sect3 id="sect-basics-dbus-python-methods">
        <title>Calling Methods</title>
        <para>This example uses <indexterm><primary>Python</primary></indexterm>Python to call the <literal>Notify()</literal> method on the <literal>org.freedesktop.Notification</literal> interface of the desktop notification service at the <literal>/org/freedesktop/Notification</literal> path.</para>
        <para>Note that we specify reply and error handlers as keyword arguments, to call the method asynchronously because asynchronous calls are generally preferred with D-Bus.</para>
        <para><ulink url="&url_examples_base;basics_dbus_python_methods">Source Code</ulink></para>
      </sect3>

      <sect3 id="sect-basics-dbus-python-properties">
        <title>Using Properties</title>
        <para>D-Bus properties are available via an additional <ulink url="&url_dbus_spec_base;standard-interfaces-properties">org.freedesktop.DBus.Properties</ulink> interface on some objects, which provides <methodname>Get()</methodname>, <methodname>Set()</methodname> and <methodname>GetAll</methodname> methods. You can call these methods to get or set property values for the object's other interfaces.</para>
        <para>As of this writing, Python has no simple API for dealing with D-Bus properties so you must call these functions directly. Therefore this example is therefore very similar to the <link linkend="sect-basics-dbus-python-methods">Calling Methods</link> example.</para>
        <para><ulink url="&url_examples_base;basics_dbus_python_properties">Source Code</ulink></para>
      </sect3>

      <sect3 id="sect-basics-dbus-python-signals">
        <title>Handling Signals</title>
        <para>D-Bus signal handlers may be specified in Python with the proxy object's <ulink url="&url_dbus_python_base;dbus.proxies.Interface-class.html#connect_to_signal"><methodname>connect_to_signal()</methodname></ulink> method. The specified callback function will then be called when the signal is emitted. This example connects to the &quot;DeviceAdded&quot; signal of the &quot;org.freedesktop.Hal.Manager&quot; interface so it can print a message to the terminal when, for instance, you plug in a USB stick.</para>
        <para><ulink url="&url_examples_base;basics_dbus_python_signals">Source Code</ulink></para>
      </sect3>

    </sect2>
   </sect1>

   <sect1 id="sec-basics-language-bindings">
    <title>Language Bindings</title>
    <para>As mentioned in the <link linkend="sec-basics-dbus">Using D-Bus</link> section, many programming languages have their own generic ways of using D-Bus APIs. In addition, there are some Telepathy-specific APIs to make the use of Telepathy even easier. For instance, <ulink url="http://telepathy.freedesktop.org/wiki/Telepathy%20GLib">telepathy-glib</ulink> provides an API that is familiar to users of Glib and GTK+, using the GObject system and related conventions.</para>
    <para>Likewise, the <ulink url="http://telepathy.freedesktop.org/wiki/TelepathyQt">Telepathy-Qt</ulink> project provides a more Qt-like API for Telepathy and <ulink url="http://telepathy.freedesktop.org/wiki/Telepathy%20Python">Telepathy-Python</ulink> does the same for Python.</para> <!-- TODO: Link to Telepathy-Qt4 when it is ready. -->

    <para>Remember that, like raw use of D-Bus from these programming languages, the Telepathy language bindings only create <literal>proxies</literal> to the D-Bus objects, providing a way to use their API. The actual objects are instantiated in the service's process.</para>
  
    <sect2 id="sec-basics-language-bindings-telepathy-glib">
      <title>telepathy-glib</title>
      <para>The C examples in this book will use telepathy-glib, which provides a GObject-based API for the Telepathy framework.</para>

      <!-- TODO: Mention this? 
      <para>The reference documentation only makes sense in terms of the Telepathy D-Bus Specification.</para>
      -->

      <sect3 id="sec-basics-language-bindings-telepathy-glib-async">
        <title>Asynchronous Calls</title>
        <para>For each Telepathy D-Bus method, telepathy-glib generally provides both a &quot;run&quot; and a &quot;call&quot; function. For instance, <ulink url="&url_telepathy_glib_base;connection.html#tp-cli-connection-run-connect">tp_cli_connection_run_connect()</ulink> and <ulink url="&url_telepathy_glib_base;connection.html#tp-cli-connection-call-connect">tp_cli_connection_call_connect()</ulink>. The &quot;run&quot; function is synchronous, blocking until the D-Bus service has returned the value, whereas the &quot;call&quot; function is asynchronous, immediately returning and later providing the result to a callback function.</para>
        <para>
	 However, the use of the &quot;run&quot; functions is strongly
	 discouraged (see <xref linkend="warning.dbus.sync"/>), so all
	 examples in this book will use the asynchronous &quot;call&quot;
	 functions. While this might seem to complicate the examples,
	 it is more robust and means the applications will be more responsive.
	</para>
      </sect3>

      <sect3 id="sec-basics-language-bindings-telepathy-glib-generated">
        <title>Generated Functions</title>
        <para>telepathy-glib provides both hand-coded and generated API. The generated functions have these prefixes:</para>

        <variablelist>

          <varlistentry>
            <term>tp_cli_</term> 
            <listitem>
              <para>These functions are useful for client applications. For instance, <ulink url="&url_telepathy_glib_base;connection.html#tp-cli-connection-run-connect">tp_cli_connection_run_connect()</ulink>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>tp_svc_</term> 
            <listitem>
              <para>These functions are useful for service implementations, such as connection managers. For instance, <ulink url="&url_telepathy_glib_base;svc-connection.html#tp-svc-connection-implement-connect">tp_svc_connection_implement_connect()</ulink>.</para>
            </listitem>
          </varlistentry>

        </variablelist>

        <para>The generated functions make simple direct calls to the D-Bus methods, without any additional logic and without using more appropriate types. For instance, they use unsigned integers for parameters because D-Bus does not have a concept of enumerations. However, the Telepathy D-Bus Specification does describe enumerations of possible values for these parameters, so the hand-written functions do use enums. Likewise, raw D-Bus methods can only identify object instances in terms of a <literal>bus name</literal> and <literal>object path</literal> combination, but telepathy-glib can directly provide a GObject instance that is a proxy for a D-Bus object without exposing those intermediate details.</para>
        <para>Hand-coded functions have a simple <literal>tp_</literal> prefix and should be preferred whenever they exist. The generated functions exist only because hand-written functions have not yet been implemented for all Telepathy D-Bus methods.</para>  
        <para>In addition to more pleasant syntax, some hand-written objects contain a large amount of useful logic which can simplify application code. For instance, <ulink url="&url_telepathy_glib_base;contact.html"><classname>TpContact</classname></ulink> uses GObject signals. <!-- TODO: Finish this sentence. --></para>
      </sect3>

      <sect3>
        <title>Instantiation and Readiness</title>
        <!-- TODO: Keep any eye on http://bugs.freedesktop.org/show_bug.cgi?id=13422 -->
        <para>Some of the hand-coded objects, such as <ulink url="&url_telepathy_glib_base;connection.html"><classname>TpConnection</classname></ulink> and <ulink url="&url_telepathy_glib_base;connection.html"><classname>TpChannel</classname></ulink>, call additional D-Bus methods to acquire necessary information. When they have received this information they are then &quot;ready&quot;, meaning that other hand-written functions can then be called. This concept of &quot;readiness&quot; does not exist in the raw D-Bus API because it describes the status of the hand-written behaviour. For instance, you should call <ulink url="&url_telepathy_glib_base;connection.html#tp-connection-call-when-ready">tp_connection_call_when_ready()</ulink> after instantiating a TpConnection, or <ulink url="&url_telepathy_glib_base;channel.html#tp-channel-call-when-ready">tp_channel_call_when_ready()</ulink> after instantiating a TpChannel.</para>

      </sect3>

      <sect3>
        <title>Headers and Linking</title>
        <para>To use the telepathy-glib API, you must include the headers for the library, and link to its shared library. The necessary compiler and linker commands can be obtained from the <literal>pkg-config</literal> utiltity like so:</para>
        <para>
<programlisting>
pkg-config telepathy-glib --cflags
pkg-config telepathy-glib --libs
</programlisting>
        </para>
        <para>However, if you are using the &quot;autotools&quot; (automake, autoconf, etc) build system, you will find it more convenient to use the <function>PKG_CHECK_MODULES</function> macro in your <literal>configure.ac</literal> file.
       </para>
       <para>
<programlisting>
PKG_CHECK_MODULES(EXAMPLE, telepathy-glib)
AC_SUBST(EXAMPLE_CFLAGS)
AC_SUBST(EXAMPLE_LIBS)
</programlisting>
        </para>
        <para>You should then use the generated _CFLAGS and _LIBS definitions in your Makefile.am files.</para>
      </sect3>

    </sect2>

  </sect1>

  <!-- TODO: Notes: The interfaces are often called their type, particularly for channels. Explain. -->
  <sect1 id="sec-basics-optional-interfaces">
    <title>Optional Interfaces</title>
    <para>Although a core set of D-Bus interfaces is provided by all connection managers, some extra D-Bus interfaces are optional. For instance, some connection managers only provide extra interfaces when they discover that the remote server provides that optional functionality. Therefore, when using these interfaces, application code should first check that the interface is available, sometimes falling back to alternative interfaces.</para>
    <para>For instance, use the <interfacename>Connection</interfacename> interface's <ulink url="&url_spec_base;Connection.GetInterfaces"><methodname>GetInterfaces()</methodname></ulink> method. For <interfacename>ConnectionManager</interfacename>s and <interfacename>Channel</interfacename>s use their <property>Interfaces</property> D-Bus property. Eventually <interfacename>Connection</interfacename> will also have an <property>Interfaces</property> property, when its <methodname>GetInterfaces()</methodname> method will be deprecated.</para>

    <para>When using telepathy-glib, you can simply call the <ulink url="&url_telepathy_glib_base;proxy.html#tp-proxy-has-interface"><function>tp_proxy_has_interface()</function></ulink> function for <classname>TpConnectionManager</classname>, <classname>TpConnection</classname>, or <classname>TpChannel</classname>.</para> 
    <para>Actually, the core interfaces are only &quot;recommended&quot; by the Telepathy D-Bus specification so you should check before using any interface even if it is not commonly considered to be optional.</para>

    <note>
    <para>Note that the <property>Interfaces</property> property (or the <ulink url="&url_spec_base;Connection.GetInterfaces"><methodname>Connection.GetInterfaces()</methodname></ulink> method) does more than the standard D-Bus <ulink url="&url_dbus_spec_base;standard-interfaces-introspectable"><methodname>Introspectable.Introspect()</methodname></ulink> method. The Telepathy-specific mechanism allows tools and language bindings to know about the possible availability of interfaces via <methodname>Introspect()</methodname> while providing an additional check that the interface is really supported for the particular connection manager with the particular remote server to which that connection manager is connected. 
    </para>
    </note>

    <!-- TODO: Add dbus-glib and Python examples of checking-for and using an Interface. -->
  </sect1>

  <!-- TODO: Should we even mention this before the new (5?) version is ready?
  <sect1 id="sec-basics-mission-control">
    <title>Mission Control</title>
    <para>TODO: Notes: desktop-wide accounts and dispatching to applications. 
    </para>
  </sect1>
  -->

  <sect1 id="sec-basics-handles">
    <title>Handles</title>
    <para>The Telepathy D-Bus API does not have D-Bus objects to represent contacts, groups, or rooms. These are instead identified by numeric <literal>handles</literal>. This is for performance reasons, and because it is easier to compare numeric handles than to discover if two D-Bus proxy objects refer to the same object instance.</para>
    <para>These numeric handles are only unique within a Telepathy Connection. For instance, don't try to use a Connection's contact handle with a different Connection. The handles also only make sense when combined with a <ulink url="&url_spec;#type-Handle_Type">handle type</ulink>, telling the API whether it represents a contact, group, or list. In fact, two handles may be numerically identical but be for different types.</para>

    <sect2>
      <title>Hold and Release</title>
      <para>When a Telepathy object has finished with a handle that number may be forgotten and even reused later as a handle for a completely different item. However, your application may wish to &quot;hold&quot; the handle for a longer time. To do so, you should call the Connection's <ulink url="&url_spec_base;Connection.HoldHandles"><methodname>HoldHandles()</methodname></ulink> method and call <ulink url="&url_spec_base;Connection.ReleaseHandles"><methodname>ReleaseHandles()</methodname></ulink> when you have finished with the handle. However, a single <methodname>ReleaseHandles()</methodname> call will release a handle regardless of how many times <methodname>HoldHandles()</methodname> has been called, so be careful not to call it while other code may be using the handle.</para>

      <para>This is less necessary when using Telepathy <link linkend="sec-basics-language-bindings">language bindings</link>, such as telepathy-glib, because they may automatically hold and release handles for the lifetime of their objects, such as telepathy-glib's <classname>TpContact</classname> object. Additionally, telepathy-glib wraps the <methodname>HoldHandles()</methodname> and <methodname>ReleaseHandles()</methodname> D-Bus methods with the <ulink url="&url_telepathy_glib_base;connection.html#tp-connection-hold-handles"><function>tp_connection_hold_handles()</function></ulink> and <ulink url="&url_telepathy_glib_base;connection.html#tp-connection-unref-handles"><function>tp_connection_unref_handles()</function></ulink> functions which reference-count the client-side handle &quot;hold&quot;, allowing you to match each <function>tp_connection_hold_handles()</function> call with a call to <function>tp_connection_release_handles()</function>.</para>

      <!-- TODO: On irc, smcv said: "perhaps "the user types in the name of a chatroom to join" would be a better example of when you want to use tp_connection_request_handles/tp_connection_unref_handles". Explain that more fully. -->

      <para>In the later sections we will mention when it actually makes sense to do this when using specific parts of the Telapathy API.</para>
    </sect2>

  </sect1>

  <sect1 id="sec-basics-api-conventions">
    <title>API conventions</title>
    <para>Telepathy's method names follow a simple convention.</para>
    <orderedlist>
      <listitem><simpara>Methods prefixed with <literal>Request</literal> are aysnchronous, meaning that the result will be provided later and your application should not block while it waits. For instance, <ulink url="&url_spec_base;Connection.RequestChannel"><methodname>Connection.RequestChannel()</methodname></ulink>.</simpara></listitem>
      <!-- TODO: What is the D-Bus convention for the separator? . or :: ? -->
      <listitem><simpara>Methods prefixed with <literal>Get</literal> are synchronous, meaning that the result will be returned immediately. These methods generally access local information and do not need to make any contact with the remote server. For instance, <ulink url="&url_spec_base;Connection.GetStatus"><methodname>Connection.GetStatus()</methodname></ulink>.</simpara></listitem>
    </orderedlist>

    <para>See the <link linkend="sec-basics-dbus">Using D-Bus</link> section to learn more about asynchronous D-Bus method calls. Note that many <literal>Get</literal> methods may be replaced with D-Bus properties in future, which will also be syncronous.</para>

    <para>See also the <link linkend="sec-basics-language-bindings-telepathy-glib">telepathy-glib</link> section about its function naming conventions.</para>
  </sect1>

</chapter>

<chapter id="chapter-accounts">
  <title>TODO: Accounts and AccountManager</title>
  <para>TODO:
   Notes:
   - This is described in the telepathy specification but only partially 
     implemented in Nokia mission control.
   - AccountManager contains a list of my accounts (my jabber account, my 
     ICQ account, etc)
   - This is  a desktop-wide list of accounts shared by all applications (via 
     the Mission Control service)
     - most developers probably won't need to deal with them much.
   - This is not a list of remote accounts held by my contacts.
   - Includes the parameters which are passed to RequestConnection().
   - Includes some other parameters such as your avatar/your alias, which the 
     AccountManager takes care of setting for you
   - Responds to connectivity events/requests.
  </para>
</chapter>

<chapter id="chapter-channel-dispatcher">
  <title>TODO: ChannelDispatcher</title>
  <para>TODO:
   Notes:
   - This is in mission control.
   - This dispatches some events to applications that care about them, by 
     calling a method on the ChannelHandler interface (that the application 
     implements). This API is currently in flux.
  </para>
</chapter>

<chapter id="chapter-connection-manager">
  <title>Connection Manager</title>

<!-- these paragraphs came from Basics -->
  <sect1 id="sec-basics-connection-managers">
    <title>Connection Managers</title>
    <para>Support for the various communication protocols is provided by several <literal>Connection Managers</literal>. For instance, the <literal>telepathy-gabble</literal> Connection Manager provides support for the <acronym>XMPP</acronym> protocol, also known as <literal>Jabber</literal>.</para>
    <para>There is no central &app; D-Bus service. Instead there are several connection manager services, activated on demand, and each of these connection managers provide the same core set of D-Bus interfaces, such as <ulink url="&url_spec_base;Connection"><interfacename>Connection</interfacename></ulink> and <ulink url="&url_spec_base;Channel"><interfacename>Channel</interfacename></ulink>, allowing application code to be written generically for all connection managers.</para>
  </sect1>

<!-- these paragraphs have always been here -->
<!--
  <para>As mentioned in the <link linkend="sec-basics-connection-managers">Basics</link> chapter, each <ulink url="&url_spec_base;ConnectionManager"><interfacename>ConnectionManager</interfacename></ulink> provides support for a communication protocol.</para>
  -->

  <para>All Telepathy Connection Managers have <literal>bus name</literal>s that begin with &quot;org.freedesktop.Telepathy.ConnectionManager&quot; so you can discover all available connection managers by calling the D-Bus <ulink url="&url_dbus_spec_base;bus-messages-list-activatable-names"><methodname>ListActivatableNames()</methodname></ulink> method and then comparing the names with that prefix. telepathy-glib provides the <ulink url="&url_telepathy_glib_base;connection-manager.html#tp-list-connection-managers"><function>tp_list_connection_managers()</function></ulink> function that conveniently does this.</para>
  <para>You may then discover what protocols are provided by each connection manager by calling the ConnectionManagers's <ulink url="&url_spec_base;ConnectionManager.ListProtocols"><methodname>ListProtocols()</methodname></ulink> D-Bus method. telepathy-glib's <ulink url="&url_telepathy_glib_base;connection-manager.html"><classname>TpConnectionManager</classname></ulink> object calls this automatically and emits the <literal>got-info</literal> signal when it has returned. You can examine the TpConnectionManager::protocols struct field in your signal handler.</para>
  <para>Applications, such as IM clients, might choose to offer the user a choice from that list of protocols and then use the appropriate connection manager. Others might use only one protocol and therefore hard-code the connection manager's <literal>bus name</literal>.</para> 

  <sect1>
  <title>Protocols Listing Example</title>
    <para>This example list all available connection managers and the protocols they support.</para>
    <para><ulink url="&url_examples_base;list_all_protocols">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-connection">
  <title>Connection</title>
  
  <sect1>
    <title>Connecting</title>
    <para>To attempt a connection to the remote server, for instance to your Jabber IM account, call a <interfacename>ConnectionManager</interfacename>'s <ulink url="&url_spec_base;ConnectionManager.RequestConnection"><methodname>RequestConnection()</methodname></ulink> D-Bus method, providing the connection details. If the connection succeeds then this method returns the <literal>bus name</literal> and <literal>object path</literal> of a Telepathy <ulink url="&url_spec_base;Connection"><interfacename>Connection</interfacename></ulink> object.</para>

    <para>As of this writing, there is no hand-coded telepathy-glib function to request the connection and directly provide a <ulink url="&url_telepathy_glib_base;connection.html"><classname>TpConnection</classname></ulink> proxy. However, you may use the generated <ulink url="&url_telepathy_glib_base;connection-manager.html#tp_cli_connection_manager_call_request_connection"><function>tp_cli_connection_manager_call_request_connection()</function></ulink> function. In the callback, you can then use the provided <literal>bus name</literal> and <literal>object path</literal> to instantiate a TpConnection proxy object.</para>

    <note><para>See the <link linkend="sec-basics-language-bindings-telepathy-glib-generated">Basics</link> chapter for an explanation of hand-coded and generated API in telepathy-glib.</para></note>

    <para>See the <link linkend="chapter-channel">Channels</link> section about obtaining and using <interfacename>Channel</interfacename>s from the <interfacename>Connection</interfacename> with which you can list groups of contacts .</para>

    <!-- TODO: Mention these interfaces, mentioned by smcv on irc: Requests and Contacts are "recommended" (every protocol ought to be able to support them), and are only non-core because they're new (so clients can discover whether they're present)
 murrayc: when we eventually remove deprecated stuff, it's likely that Requests and Contacts will become part of Connection -->

    <sect2>
      <title>Connection Example</title>
      <para>This example connects to a jabber account.</para>
      <para><ulink url="&url_examples_base;connect">Source Code</ulink></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Presence</title>
    <para>If a protocol has a concept of presence, showing when users are online or available, then that <interfacename>ConnectionManager</interfacename>'s <interfacename>Connection</interfacename> will provide the <ulink url="&url_spec_base;Connection.Interface.SimplePresence"><interfacename>SimplePresence</interfacename></ulink> interface. This interface has functions to set and get the current presence for the connected account. It also has a <ulink url="&url_spec_base;Connection.Interface.SimplePresence.PresencesChanged">PresencesChanged</ulink> signal to detect changes to the presence caused by other clients.</para>

    <sect2>
      <title>Presence Example</title>
      <para>This example sets the presence for a jabber account, by calling the <methodname>SetPresence()</methodname> method of the <interfacename>Connection</interfacename>'s <interfacename>SimplePresence</interfacename> interface, using telepathy-glib.</para>
      <para><ulink url="&url_examples_base;set_presence">Source Code</ulink></para>
    </sect2>

  </sect1>

  <sect1>
    <title>Optional Interfaces</title>
    <para>As mentioned in the <link linkend="sec-basics-optional-interfaces">Basics</link> section, the <interfacename>Connection</interfacename> may provide several optional interfaces, depending on the <interfacename>ConnectionManager</interfacename> used and depending on the capabilities of the remote server.</para>

    <para>For instance, these interfaces are present if the remote server or its protocol provides that functionality:</para>

    <!-- TODO: Are there other potential optional Connection interfaces. I can't tell from the Spec. murrayc. -->
    <variablelist>

       <varlistentry>
         <term>
           <indexterm><primary>Aliasing</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.Aliasing"><interfacename>Aliasing</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO: Notes: provides other information about contacts, and notifications when they change.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>Avatars</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.Avatars"><interfacename>Avatars</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO: Notes: provides other information about contacts, and notifications when they change.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>Presence</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.Presence"><interfacename>Presence</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO</para>
         </listitem>
       </varlistentry>

    </variablelist>

    <para>These newer interfaces are present if the <interfacename>ConnectionManager</interfacename> has implemented them already. They generally replace older deprecated interfaces. They must be optional to avoid forcing all <interfacename>ConnectionManager</interfacename>s and all client code to use the new interfaces immediately.</para>

    <!-- TODO: Are there other potential optional Connection interfaces. I can't tell from the Spec. murrayc. -->
    <variablelist>

       <varlistentry>
         <term>
           <indexterm><primary>Requests</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.Requests"><interfacename>Requests</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO: Notes: improves a similar existing interface - instead of <ulink url="&url_spec_base;Connection.RequestChannel">Connection.RequestChannel</ulink>.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>
           <indexterm><primary>SimplePresence</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.SimplePresence"><interfacename>SimplePresence</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO: Notes: to which I can give a contact handle 
     to discover if that contact is online. The SimplePresence interface emits 
     signals when contacts' presence changes.
     (SimplePresence replaces the <ulink url="&url_spec_base;Connection.Interface.Presence">Presence</ulink> interface, to be deprecated soon.)</para>
         </listitem>
       </varlistentry>

       <!-- TODO: Mention this when it is out of draft: - A new <ulink url="&url_spec_base;Connection.Interface.ContactCapabilities.DRAFT">ContactCapabilities</ulink> interface will allow retrieving of multiple 
     types of information at once (string of handle, alias, avatar, presence, etc), 
     which is more efficient.
       -->

    </variablelist>

  </sect1>


</chapter>

<chapter id="chapter-channel">
  <title>Channel</title>



  <para>TODO:
   Notes:
   - A connection has <ulink url="&url_spec_base;Channel">Channel</ulink>s.
   - Connection gives me several <ulink url="&url_spec_base;Channel.Type.ContactList">ContactList</ulink> Channels (subscribe, publish, etc)
     - Provides a <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface.
       - Contains many members (Contact handles). 
   - Has a <ulink url="&url_spec_base;Connection.RequestChannel">RequestChannel()</ulink> method that takes a channel type (text/voip/tubes) 
     and a handle (contact, room, list or group) handle. 
  </para>

  <para>TODO:
   Notes:
   - <ulink url="&url_spec_base;Connection.RequestChannel">Connection.RequestChannel</ulink>, <ulink url="&url_spec_base;Channel">Channel</ulink>
   - Allows data exchange between the local account and a remote IM account 
     (or group of remote accounts).
   - Only an application knows about actual people (who might have many IM 
     accounts).
   - (We need to call them something other than "IM accounts" because it is not 
     just IM. It can be "people nearby", for instance.)
   - Maybe an instance of one of these communication types: Text, Contact List, 
     Streamed Media.
   - Channel provides (maybe _is_) a contacts list. Usually 2 people (local me 
     and my remote contact), but x people for a chat group.
   - The base Channel interface provides channel type, handle and Interfaces 
     properties, and Close method, Closed signal.
 
   - Mention basic channel requesting and then advanced channel requesting.
     (The new API makes it easier to do these things.)
   - You'd need two channels for two types of communication with the same 
     contact. (At least with the new API.)
   - Has capabilities. (API will change).
     - Tells me what type of channel I can open on a connection/contact. 
       For instance, text/media/tube.
  </para>

  <sect1>
    <title>Optional Interfaces</title>
    <para>As mentioned in the <link linkend="sec-basics-optional-interfaces">Basics</link> section, the <interfacename>Channel</interfacename> may provide several optional interfaces, depending on the <interfacename>ConnectionManager</interfacename> used and depending on the capabilities of the remote server.</para>

    <para>For instance, these interfaces are present if the remote server or its protocol provides that functionality:</para>

    <para>TODO: 
    - Plus one type-specific interface, such as Text, or Tube, Media.
   - This is also sometimes a <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface, for instance if it's a group chat.
   - Media channels may have DTMF, Hold, CallStates (on hold, ringing, etc) 
     interfaces
   - Text channels may have ChatState (typing notification), Messages (rich 
     messages), Password interfaces
    </para>

    <!-- TODO: Are there other potential optional Channel interfaces. I can't tell from the Spec. murrayc. -->
    <variablelist>

       <varlistentry>
         <term>
           <indexterm><primary>Group</primary></indexterm>
           <ulink url="&url_spec_base;Connection.Interface.Group"><interfacename>Group</interfacename></ulink>
         </term>
         <listitem>
           <para>TODO.</para>
         </listitem>
       </varlistentry>

    </variablelist>

  </sect1>

  <sect1>
  <title>Message Send Example</title>
  <para>This example sends a text message to a jabber contact via a text channel.</para>
  <para><ulink url="&url_examples_base;send_message">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-group">
   <title>Group Interface</title>
   <para>TODO:
   (used in lots of different channels)
   - This is partitioned into:
     - Current members
     - Local pending members, awaiting approval (by doing Add or Remove) by the 
       local user.
     - Remote pending members, awaiting approval remotely by the other user)
   - Unusually, one-to-one calls use the <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface to indicate call 
     progression (explain in call section?).
  </para>
</chapter>

<chapter id="chapter-tubes">
  <title>Tubes</title>
  <para>TODO:
   - Helps me to implement an ad-hoc protocol or data-exchange structure above 
     what the IM protocol does.
   - You wouldn't need a tube for a chat, because the IM protocol has that 
     already, but you'd need to implement more for some custom thing like 
     networking of a game.
   - Streamed Media Channels
  </para>
</chapter>

<!-- TODO:
Wait for the new specs (2008, Q3):
   - Capabilities interface(s) on Connection
   - Channel Dispatching
   - Channel Requesting
   - Client interfaces
-->

<!--
Note: The following sections are more tutorial-like, describing how to implement 
real functionality, with full examples. The full examples will have a very 
simple GTK+ UI and will be implemented with dbus-glib. There will also be small 
code snippets which will also be in dbus-glib, but python versions could be 
added in future.
-->

<chapter id="chapter-contacts">
  <title>Accessing/managing contact information</title> <!-- TODO: rename the title. -->
  <para>TODO:
 - Contact Lists
   - publish/subscribe
   - Groups
 - Contact Information
   - Aliases
   - Avatars
   - Presence
  </para>

  <sect1>
  <title>Example</title>
  <para>This example connects to a jabber account and lists all contacts for that account.</para>
  <para><ulink url="&url_examples_base;list_contacts">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-chat-client">
  <title>Implementing a Chat Client</title>
  <para>TODO:
 - Text Channels (Messages Interface?)
  </para>
</chapter>

<chapter id="chapter-voip-client">
  <title>Creating a VoIP Client</title>
  <para>TODO: 
  (Streaming Audio/Video)
  - Will require some gstreamer knowledge for recording and playback.
  </para>
</chapter>

<chapter id="chapter-transferring-files">
  <title>Transferring Files</title>
  <para>TODO
  </para>
</chapter>

<chapter id="chapter-networked-application">
  <title>Making an application networked</title> <!-- TODO: Rename the title. -->
  <para>TODO:
  - For instance, turn-based Tic-Tac-Toe.
  </para>
</chapter>

<index id="refindex">
</index>

</book>
