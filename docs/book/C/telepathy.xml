<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

  <!-- These entities are used in the generated .omf files, 
       along with the author tags,
       allowing the Yelp help browser to know about the document.
 
       The legal.xml file contains legal information, there is no need to edit the file. 
       Use the appversion entity to specify the version of the application.
       Use the manrevision entity to specify the revision number of this manual.
       Use the date entity to specify the release date of this manual.
       Use the app entity to specify the name of the application. -->
  <!ENTITY legal SYSTEM "legal.xml">
  <!ENTITY appversion "0.7">
  <!ENTITY manrevision "0.2">
  <!ENTITY date "12 August 2008">
  <!ENTITY app_no_markup "Telepathy">
  <!ENTITY app "<application>&app_no_markup;</application>">
  <!ENTITY url_examples_base "./examples/">
  <!ENTITY url_spec "http://telepathy.freedesktop.org/spec.html">
  <!ENTITY url_spec_base "&url_spec;#org.freedesktop.Telepathy.">
]>

<book id="index">
  <bookinfo>
    <title>&app; manual</title>

    <!-- If we were using the FDL license then we would need full revision 
         tags instead of just this one date.
         Actually, it seems that DocBook allows just a single date tag without 
         these revhistory tags, but maybe gnome-doc-utils cannot cope with 
         that. -->
    <revhistory>
      <revision> 
        <revnumber>&app_no_markup; &appversion;</revnumber> 
          <date>&date;</date> 
          <revdescription> 
            <para role="author">Murray Cumming</para> 
            <para role="publisher">&app;</para> 
	  </revdescription> 
      </revision>
    </revhistory> 

    <authorgroup>
      <author role="maintainer"> 
        <firstname>Murray</firstname> 
        <surname>Cumming</surname> 
        <affiliation> 
          <orgname>&app_no_markup; Documentation Team</orgname> 
          <address> <email>murrayc@openismus.com</email> </address> 
        </affiliation> 
      </author> 
    </authorgroup>
      

    <copyright>
      <year>2008</year>
      <holder>Collabora Ltd</holder>
    </copyright>

    <abstract role="description">
      <para>Software development manual for &app;.</para>
    </abstract>


  <xi:include href="legal.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>

  </bookinfo>
      
<chapter id="chapter-introduction">
  <title>Introduction</title>
  <para>The Telepathy framework allows applications to use real-time communications via several common protocols, such as XMPP (Jabber). For instance, an instant messenger application might use Telepathy to allow chats with online contacts via accounts with various IM services. Or a  game might use Telepathy to simplify the implementation of its networking code, allowing users to play against each other.</para>
  <para>Telepathy is a <ulink url="http://www.freedesktop.org/wiki/Software/dbus">D-Bus</ulink> API so it may be used from most programming languages.</para>
  <para>All this functionality is available under an open source license, allowing people to make improvements and add new features.</para>

  <para>TODO:  What are the benefits? How is it better than the alternatives? (If there are any). Is it easier, robuster, more secure, more flexible, cheaper, free-er, what?</para>
</chapter>


<!--
Notes:
- The following sections describe important D-Bus API in telepathy.
These sections will describe how these interfaces can be used, including small 
code snippets.
- Where possible the documentation will pull in small but complete 
code examples which can build as part of the documentation, guaranteeing that 
they at least compile with the latest API, and making it easier to test that 
they really work.
- Wherever interfaces are mentioned, there will be a links to online API 
reference documentation (assuming that it exists) and links to relevant parts 
of the Telapathy specification. 
-->

<chapter id="chapter-basics">
  <title>Basics</title>

  <sect1 id="sec-basics-dbus">
    <title>Using D-Bus</title>
    <para>Telepathy is a D-Bus API. Telepathy components conform to the <ulink url="&url_spec;">Telepathy D-Bus Specification</ulink>, which is therefore also the main Telepathy API reference.</para>
    <para>D-Bus is an IPC (Inter-process communication) system, allowing different software components to be implemented in different processes, with different programming languages. It also allows multiple applications to easily share functionality from a single process.</para>
    <!-- TODO: Mention basic D-Bus concepts, though try not to overwhelm the reader so early. -->

    <para>In the following sections you can see how a D-Bus API can be used from some common programming languages.</para>

    <sect2 id="sec-basics-dbus-glib">
      <title>Using D-Bus from C, with glib</title>
      <para>TODO</para>

      <sect3>
      <title>Example</title>
      <para>This example used dbus-glib to call the <literal>Notify()</literal> method on the <literal>org.freedesktop.Notification</literal> interface of the desktop notification service at the <literal>/org/freedesktop/Notification</literal> path.</para>
      <para><ulink url="&url_examples_base;basics_dbus_glib">Source Code</ulink></para>
      </sect3>

    </sect2>

    <sect2 id="sec-basics-dbus-python">
      <title>Using D-Bus from Python</title>
      <para>TODO</para>

      <sect3>
      <title>Example</title>
      <para>This example used Python to call the <literal>Notify()</literal> method on the <literal>org.freedesktop.Notification</literal> interface of the desktop notification service at the <literal>/org/freedesktop/Notification</literal> path.</para>
      <para><ulink url="&url_examples_base;basics_dbus_python">Source Code</ulink></para>
      </sect3>

    </sect2>
   </sect1>

   <sect1 id="sec-basics-language-bindings">
    <title>Language Bindings</title>
    <para>As mentioned in the <link linkend="sec-basics-dbus">Using D-Bus</link> section, many programming languages have their own generic ways of using D-Bus APIs. In addition, there are some Telepathy-specific APIs to make the use of Telepathy even easier. For instance, <ulink url="http://telepathy.freedesktop.org/wiki/Telepathy%20GLib">telepathy-glib</ulink> provides an API that is familiar to users of Glib and GTK+, using the GObject system and related conventions.</para>
    <para>Likewise, the <ulink url="http://telepathy.freedesktop.org/wiki/TelepathyQt">Telepathy-Qt</ulink> project provides a more Qt-like API for Telepathy and <ulink url="http://telepathy.freedesktop.org/wiki/Telepathy%20Python">Telepathy-Python</ulink> does the same for Python.</para> <!-- TODO: Link to Telepathy-Qt4 when it is ready. -->
    <para>The C examples in this book will use telepathy-glib.</para>

   </sect1>

  <sect1 id="sec-basics-connection-managers">
    <title>Connection Managers</title>
    <para>Support for the various communication protocols is provided by various <literal>Connection Managers</literal>. For instance, the <literal>telepathy-gabble</literal> Connection Manager provides support for the <acronym>XMPP</acronym> protocol, also known as <literal>Jabber</literal>.</para>
    <para>There is no central &app; D-Bus service. Instead there are several connection manager services, activated on demand, and each of these connection managers provide the same core set of D-Bus interfaces, such as <ulink url="&url_spec_base;Connection">Connection</ulink> and <ulink url="&url_spec_base;Channel">Channel</ulink>, allowing application code to be written generically for all connection managers.</para>
  </sect1>

  <!-- TODO: Notes: The interfaces are often called their type, particularly for channels. Explain. -->
  <!-- TODO: Is it only Connection that has optional interfaces? -->
  <sect1 id="sec-basics-optional-interfaces">
    <title>Optional Interfaces</title>
    <para>Although a core set of D-Bus interfaces is provided by all connection managers, some extra D-Bus interfaces are optional. For instance, some connection managers only provide extra interfaces when it discovers that the remote server provides that optional functionality. Therefore, when using these interfaces, application code should first check that the interface is available, sometimes falling back to alternative interfaces. Use the Connection interface's <ulink url="&url_spec_base;Connection.GetInterfaces"><function>GetInterfaces()</function></ulink> method for this.</para>

    <note>
    <para>Note that the <ulink url="&url_spec_base;Connection.GetInterfaces"><function>Connection.GetInterfaces()</function></ulink> method  does more than the standard D-Bus <ulink url="http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-introspectable"><function>Introspectable.Introspect()</function></ulink> method. <function>GetInterfaces()</function> allows tools and language bindings to know about the possible availability of interfaces via <function>Introspect()</function> while providing an additional check that the interface is really supported for the particular connection manager with the particular remote server to which that connection manager is connected. 
    </para>
    </note>
  </sect1>

  <sect1 id="sec-basics-mission-control">
    <title>Mission Control</title>
    <para>TODO: Notes: desktop-wide accounts and dispatching to applications. TODO: Should we even mention this before the new (5?) version is ready?
    </para>
  </sect1>

  <sect1 id="sec-basics-handles">
    <title>Handles</title>
    <para>TODO:
    - Hold and Release.
    - Like ref-counting but 2 Holds by the same client is 1 hold 
      (Mission Control keeps a set of referencing clients)
    - See <ulink url="&url_spec_base;Connection">Connection</ulink>
    </para>
  </sect1>

  <sect1 id="sec-basics-api-conventions">
    <title>API conventions</title>
    <para>TODO: Notes: For instance"Request*" vs. "Get*" - see Asynchronous Calls.
    </para>
  </sect1>

  <sect1 id="sec-basics-asynchronous-calls">
    <title>Asynchronous Calls</title>
    <para>TODO: 
    Notes: Most functions are synchronous, getting locally-stored data.
    - Convention is that Get* methods access local information, but Request* 
      methods may access the network.
      (This convention seems to apply to the D-Bus API, but not to the telepathy-glib API. murrayc)
    - Many Get* methods are being deprecated in favour of D-Bus properties 
      currently (because you can do GetAll() for a given interface and download 
      the state at once with fewer roundtrips).
    </para>
  </sect1>
</chapter>

<chapter id="chapter-accounts">
  <title>Accounts and AccountManager</title>
  <para>TODO:
   Notes:
   - This is described in the telepathy specification but only partially 
     implemented in Nokia mission control.
   - AccountManager contains a list of my accounts (my jabber account, my 
     ICQ account, etc)
   - This is  a desktop-wide list of accounts shared by all applications (via 
     the Mission Control service)
     - most developers probably won't need to deal with them much.
   - This is not a list of remote accounts held by my contacts.
   - Includes the parameters which are passed to RequestConnection().
   - Includes some other parameters such as your avatar/your alias, which the 
     AccountManager takes care of setting for you
   - Responds to connectivity events/requests.
  </para>
</chapter>

<chapter id="chapter-channel-dispatcher">
  <title>ChannelDispatcher</title>
  <para>TODO:
   Notes:
   - This is in mission control.
   - This dispatches some events to applications that care about them, by 
     calling a method on the ChannelHandler interface (that the application 
     implements). This API is currently in flux.
  </para>
</chapter>

<chapter id="chapter-connection-manager">
  <title>Connection Manager</title>
  <para>TODO:
   Notes:
   - Provides protocol implementations, allowing telepathy to use additional IM 
     types, for instance.
   - This has connections.
   - This is not used much by developers, but the list of connection managers 
     should be offered by the desktop-wide accounts UI.
  </para>
</chapter>

<chapter id="chapter-connection">
  <title>Connection</title>
  <para>TODO:
   Notes:
   - This is my connection to my IM account.
   - A connection has <ulink url="&url_spec_base;Channel">Channel</ulink>s.
   - Connection gives me several <ulink url="&url_spec_base;Channel.Type.ContactList">ContactList</ulink> Channels (subscribe, publish, etc)
     - Provides a <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface.
       - Contains many members (Contact handles). Note that there is no Contact interface or object (just a handle), for performance reasons.
   - Has several optional interfaces (Avatars, Presence, etc).
     - And some optional interfaces that just improve similar existing interfaces, such as <ulink url="&url_spec_base;Connection.Interface.Requests">Connection.Interface.Requests</ulink>
       instead of <ulink url="&url_spec_base;Connection.RequestChannel">Connection.RequestChannel</ulink>
   - Provides a <ulink url="&url_spec_base;Connection.Interface.SimplePresence">SimplePresence</ulink> interface, to which I can give a contact handle 
     to discover if that contact is online. The SimplePresence interface emits 
     signals when contacts' presence changes.
     (SimplePresence replaces the <ulink url="&url_spec_base;Connection.Interface.Presence">Presence</ulink> interface, to be deprecated soon.)
   - Similarly, the <ulink url="&url_spec_base;Connection.Interface.Avatars">Avatars</ulink> and <ulink url="&url_spec_base;Connection.Interface.Aliasing">Aliasing</ulink> interfaces on the Connection provide 
     other information about contacts, and notifications when they change. 
   - (Having interfaces on the connection rather than the contacts makes 
     overall contact handling easier.)
   - Has a <ulink url="&url_spec_base;Connection.RequestChannel">RequestChannel()</ulink> method that takes a channel type (text/voip/tubes) 
     and a handle (contact, room, list or group) handle. 
   - A new <ulink url="&url_spec_base;Connection.Interface.ContactCapabilities.DRAFT">ContactCapabilities</ulink> interface will allow retrieving of multiple 
     types of information at once (string of handle, alias, avatar, presence, etc), 
     which is more efficient.
  </para>

  <sect1>
  <title>Connection Example</title>
  <para>This example connects to a jabber account.</para>
  <para><ulink url="&url_examples_base;connect">Source Code</ulink></para>
  </sect1>

  <sect1>
  <title>Presence Example</title>
  <para>This example sets the presence for a jabber account.</para>
  <para><ulink url="&url_examples_base;set_presence">Source Code</ulink></para>
  </sect1>

  <sect1>
  <title>Protocols Listing Example</title>
  <para>This example list all available connection managers and the protocols that they support.</para>
  <para><ulink url="&url_examples_base;list_all_protocols">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-handle">
  <title>Handle</title>
  <para>TODO:
   Notes:
   - <ulink url="&url_spec_base;Connection.RequestHandles">RequestHandles()</ulink>
   - Could be a contact, contact list, room, etc.
   - Note that there is no Contact interface or object (just a handle), for performance reasons.
   - Means that clients don't have to worry about normalisation.
   - (Not necessarily a nice thing, but simplifies work across processes.)
   - Important because it confuses people often.
   - Maybe put this chapter before the others if these aer shown in the early 
     examples, though Handlers are already mentioned in the Basics chapter.
  </para>
</chapter>

<chapter id="chapter-channel">
  <title>Channel</title>
  <para>TODO:
   Notes:
   - <ulink url="&url_spec_base;Connection.RequestChannel">Connection.RequestChannel</ulink>, <ulink url="&url_spec_base;Channel">Channel</ulink>
   - Allows data exchange between the local account and a remote IM account 
     (or group of remote accounts).
   - Only an application knows about actual people (who might have many IM 
     accounts).
   - (We need to call them something other than "IM accounts" because it is not 
     just IM. It can be "people nearby", for instance.)
   - Maybe an instance of one of these communication types: Text, Contact List, 
     Streamed Media.
   - Channel provides (maybe _is_) a contacts list. Usually 2 people (local me 
     and my remote contact), but x people for a chat group.
   - The base Channel interface provides channel type, handle and interface 
     properties, and Close method, Closed signal.
   - Plus one type-specific interface, such as Text, or Tube, Media.
   - This is also sometimes a <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface, for instance if it's a group chat.
   - Optional interfaces such as Group are discovered by inspecting the 
     Interfaces property.
   - Media channels may have DTMF, Hold, CallStates (on hold, ringing, etc) 
     interfaces
   - Text channels may have ChatState (typing notification), Messages (rich 
     messages), Password interfaces
   - Mention basic channel requesting and then advanced channel requesting.
     (The new API makes it easier to do these things.)
   - You'd need two channels for two types of communication with the same 
     contact. (At least with the new API.)
   - Has capabilities. (API will change).
     - Tells me what type of channel I can open on a connection/contact. 
       For instance, text/media/tube.
  </para>

  <sect1>
  <title>Example</title>
  <para>This example sends a text message to a jabber contact via a text channel.</para>
  <para><ulink url="&url_examples_base;send_message">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-group">
   <title>Group Interface</title>
   <para>TODO:
   (used in lots of different channels)
   - This is partitioned into:
     - Current members
     - Local pending members, awaiting approval (by doing Add or Remove) by the 
       local user.
     - Remote pending members, awaiting approval remotely by the other user)
   - Unusually, one-to-one calls use the <ulink url="&url_spec_base;Channel.Interface.Group">Group</ulink> interface to indicate call 
     progression (explain in call section?).
  </para>
</chapter>

<chapter id="chapter-tubes">
  <title>Tubes</title>
  <para>TODO:
   - Helps me to implement an ad-hoc protocol or data-exchange structure above 
     what the IM protocol does.
   - You wouldn't need a tube for a chat, because the IM protocol has that 
     already, but you'd need to implement more for some custom thing like 
     networking of a game.
   - Streamed Media Channels
  </para>
</chapter>

<!-- TODO:
Wait for the new specs (2008, Q3):
   - Capabilities interface(s) on Connection
   - Channel Dispatching
   - Channel Requesting
   - Client interfaces
-->

<!--
Note: The following sections are more tutorial-like, describing how to implement 
real functionality, with full examples. The full examples will have a very 
simple GTK+ UI and will be implemented with dbus-glib. There will also be small 
code snippets which will also be in dbus-glib, but python versions could be 
added in future.
-->

<chapter id="chapter-contacts">
  <title>Accessing/managing contact information</title> <!-- TODO: rename the title. -->
  <para>TODO:
 - Contact Lists
   - publish/subscribe
   - Groups
 - Contact Information
   - Aliases
   - Avatars
   - Presence
  </para>

  <sect1>
  <title>Example</title>
  <para>This example connects to a jabber account and lists all contacts for that account.</para>
  <para><ulink url="&url_examples_base;list_contacts">Source Code</ulink></para>
  </sect1>

</chapter>

<chapter id="chapter-chat-client">
  <title>Implementing a Chat Client</title>
  <para>TODO:
 - Text Channels (Messages Interface?)
  </para>
</chapter>

<chapter id="chapter-voip-client">
  <title>Creating a VoIP Client</title>
  <para>TODO: 
  (Streaming Audio/Video)
  - Will require some gstreamer knowledge for recording and playback.
  </para>
</chapter>

<chapter id="chapter-transferring-files">
  <title>Transferring Files</title>
  <para>TODO
  </para>
</chapter>

<chapter id="chapter-networked-application">
  <title>Making an appliction networked</title> <!-- TODO: Rename the title. -->
  <para>TODO:
  - For instance, turn-based Tic-Tac-Toe.
  </para>
</chapter>



</book>
